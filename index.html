<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Room Roster Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general layout */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Dark slate gray text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            background-color: #ffffff; /* White container background */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 30px;
            width: 100%;
            max-width: 1200px; /* Max width for larger screens */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #1e293b; /* Darker title */
            text-align: center;
            margin-bottom: 20px;
            font-weight: 700; /* Bold font */
        }
        .input-group label {
            font-weight: 600; /* Semi-bold label */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input[type="date"],
        .input-group textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 8px; /* Slightly rounded inputs */
            background-color: #f8fafc; /* Lighter input background */
            transition: all 0.2s ease-in-out;
        }
        .input-group input[type="date"]:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Soft focus shadow */
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: #4f46e5; /* Indigo button */
            color: white;
            border: none;
        }
        .btn:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-1px); /* Slight lift effect */
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray button */
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        .roster-output {
            overflow-x: auto; /* Enable horizontal scrolling for the table */
            margin-top: 20px;
            border: 1px solid #e2e8f0; /* Light border around roster */
            border-radius: 8px;
        }
        .roster-table {
            width: 100%;
            border-collapse: collapse; /* Collapse table borders */
            min-width: 800px; /* Ensure minimum width for scrolling */
        }
        .roster-table th,
        .roster-table td {
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e2e8f0; /* Cell borders */
            white-space: nowrap; /* Prevent date/shift wrapping */
        }
        .roster-table thead th {
            background-color: #e0e7ff; /* Light indigo header */
            font-weight: 700;
            color: #374151;
            position: sticky; /* Sticky header for scrolling */
            top: 0;
            z-index: 10;
        }
        .roster-table tbody tr:nth-child(even) {
            background-color: #f8fafc; /* Zebra striping */
        }
        .roster-table tbody tr:hover {
            background-color: #eff6ff; /* Highlight row on hover */
        }
        .roster-table td:first-child {
            text-align: left; /* Align employee names to left */
            font-weight: 500;
            background-color: #e0e7ff; /* Light indigo for employee column */
            position: sticky; /* Sticky first column */
            left: 0;
            z-index: 10;
        }
        /* Adjust sticky header background for the first column */
        .roster-table th:first-child {
            background-color: #c7d2fe; /* Darker indigo for sticky corner */
            z-index: 11; /* Ensure it's above other sticky elements */
        }
        
        /* Message box styling */
        .message-box {
            background-color: #fff3cd; /* Light yellow background */
            border: 1px solid #ffeeba; /* Yellow border */
            color: #664d03; /* Dark yellow text */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            display: none; /* Hidden by default */
        }
        .message-box.show {
            display: block;
        }

        /* Sunday Highlight Styles */
        .sunday-column-header {
            background-color: #fecaca; /* Lighter red for header */
            color: #dc2626; /* Red text */
            font-weight: 700;
        }
        .sunday-column-cell {
            background-color: #fee2e2; /* Lightest red for data cells */
            color: #b91c1c; /* Darker red text */
        }

        /* Roster Summary Styles */
        .roster-summary {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0f9ff; /* Light blue background */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .roster-summary h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 15px;
            text-align: center;
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
        }
        .summary-table th,
        .summary-table td {
            padding: 10px 15px;
            border: 1px solid #e2e8f0;
            text-align: left;
        }
        .summary-table thead th {
            background-color: #dbeafe; /* Lighter blue header */
            font-weight: 600;
            color: #1e40af;
        }
        .summary-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .summary-table tbody tr:hover {
            background-color: #e0f2fe;
        }
        .summary-table td:last-child,
        .summary-table td:nth-last-child(2),
        .summary-table td:nth-last-child(3),
        .summary-table td:nth-last-child(4) { /* Added for new columns */
            text-align: center; /* Center the calculation columns */
            font-weight: 500;
        }
    </style>
</head>
<body class="selection:bg-indigo-300">
    <div class="container">
        <h1 class="text-3xl sm:text-4xl">Control Room Roster Generator</h1>

        <div class="input-section grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="input-group">
                <label for="startDate">Roster Start Date:</label>
                <input type="date" id="startDate" class="form-input" min="" max="">
            </div>
            <div class="input-group">
                <label for="endDate">Roster End Date:</label>
                <input type="date" id="endDate" class="form-input" min="" max="">
            </div>
            <div class="input-group md:col-span-2"> <!-- Span two columns for the textarea -->
                <label for="employees">Employee Names (One per line):</label>
                <textarea id="employees" rows="8" placeholder="Enter employee names here..." class="form-textarea"></textarea>
            </div>
        </div>

        <div class="button-group">
            <button id="generateRosterBtn" class="btn">Generate Roster</button>
            <button id="exportCsvBtn" class="btn">Export to CSV</button>
            <button id="generateShiftInsightsBtn" class="btn">Generate Shift Insights âœ¨</button> <!-- New LLM Button -->
            <button id="clearRosterBtn" class="btn btn-secondary">Clear Roster</button>
        </div>

        <div id="messageBox" class="message-box"></div>

        <div id="rosterOutput" class="roster-output hidden">
            <!-- Roster table will be generated here -->
        </div>

        <div id="rosterSummary" class="roster-summary hidden">
            <h2>Roster Summary</h2>
            <div id="summaryTableContainer">
                <!-- Summary table will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variable to store shift descriptions from LLM
        let shiftDescriptions = null;

        document.addEventListener('DOMContentLoaded', () => {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const employeesTextarea = document.getElementById('employees');
            const generateRosterBtn = document.getElementById('generateRosterBtn');
            const exportCsvBtn = document.getElementById('exportCsvBtn');
            const generateShiftInsightsBtn = document.getElementById('generateShiftInsightsBtn'); // New: LLM Button
            const clearRosterBtn = document.getElementById('clearRosterBtn');
            const rosterOutputDiv = document.getElementById('rosterOutput');
            const messageBox = document.getElementById('messageBox');
            const rosterSummaryDiv = document.getElementById('rosterSummary');
            const summaryTableContainer = document.getElementById('summaryTableContainer');

            // Set min date to 2025-01-01
            const overallMinDate = `2025-01-01`;
            // Max date is December 31st of the next year from the current year
            const currentYear = new Date().getFullYear();
            const nextYear = currentYear + 1;
            const overallMaxDate = `${nextYear}-12-31`;

            startDateInput.setAttribute('min', overallMinDate);
            startDateInput.setAttribute('max', overallMaxDate);
            endDateInput.setAttribute('min', overallMinDate);
            endDateInput.setAttribute('max', overallMaxDate);

            // Set employee textarea to be blank by default
            employeesTextarea.value = '';

            // Event listener to ensure endDate is not before startDate
            startDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = new Date(startDateInput.value);
                    const end = new Date(endDateInput.value);
                    if (start > end) {
                        const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                        endDateInput.value = newEndDate.toISOString().split('T')[0];
                        showMessage('End date adjusted to be after start date.', 'info');
                    }
                } else if (startDateInput.value && !endDateInput.value) {
                    const start = new Date(startDateInput.value);
                    const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                    endDateInput.value = newEndDate.toISOString().split('T')[0];
                }
                endDateInput.setAttribute('min', startDateInput.value);
            });

            endDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = new Date(startDateInput.value);
                    const end = new Date(endDateInput.value);
                    if (start > end) {
                        showMessage('End date cannot be before start date. Please correct.', 'error');
                        endDateInput.value = '';
                    }
                }
            });


            /**
             * Displays a message in the message box.
             * @param {string} message - The message to display.
             * @param {string} type - The type of message (e.g., 'error', 'info', 'success').
             */
            function showMessage(message, type = 'info') {
                messageBox.textContent = message;
                messageBox.className = 'message-box show';
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700');
                
                if (type === 'error') {
                    messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
                } else if (type === 'success') {
                    messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
                } else {
                    messageBox.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
                }
                setTimeout(() => {
                    hideMessage();
                }, 5000);
            }

            /**
             * Hides the message box.
             */
            function hideMessage() {
                messageBox.className = 'message-box';
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700');
            }


            /**
             * Determines the shift type (D, N, O) based on the day's index within the 9-day cycle.
             * @param {number} dayIndexInCycle - The 0-indexed day within the 9-day cycle (0-8).
             * @returns {string} The shift type ('D', 'N', or 'O').
             */
            function getShiftType(dayIndexInCycle) {
                // The pattern is 3 days, 3 nights, 3 offs
                const shifts = ["D", "D", "D", "N", "N", "N", "O", "O", "O"];
                return shifts[dayIndexInCycle % shifts.length];
            }

            /**
             * Applies LLM-generated shift descriptions as tooltips to the roster cells.
             */
            function applyShiftDescriptions() {
                if (!shiftDescriptions) {
                    return; // No descriptions to apply
                }
                const shiftCells = rosterOutputDiv.querySelectorAll('.roster-table tbody td');
                shiftCells.forEach(cell => {
                    const shiftType = cell.textContent.trim();
                    if (shiftDescriptions[shiftType]) {
                        cell.setAttribute('title', shiftDescriptions[shiftType]);
                    }
                });
            }

            /**
             * Generates the roster based on the input start date and employees.
             */
            function generateRoster() {
                hideMessage();

                const startDateStr = startDateInput.value;
                const endDateStr = endDateInput.value;
                const employeesStr = employeesTextarea.value.trim();

                if (!startDateStr || !endDateStr) {
                    showMessage('Please select both a start and an end date for the roster.', 'error');
                    return;
                }
                if (!employeesStr) {
                    showMessage('Please enter employee names.', 'error');
                    return;
                }

                const employees = employeesStr.split('\n').map(name => name.trim()).filter(name => name !== '');

                const startDate = new Date(startDateStr);
                startDate.setHours(0, 0, 0, 0);
                const endDate = new Date(endDateStr);
                endDate.setHours(0, 0, 0, 0);

                if (startDate > endDate) {
                    showMessage('The start date cannot be after the end date. Please correct.', 'error');
                    return;
                }

                const dates = [];
                let currentDate = new Date(startDate);

                while (currentDate <= endDate) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                if (dates.length === 0) {
                    showMessage('No dates to generate. Please check your start and end dates.', 'error');
                    return;
                }

                // Array for short day names (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
                const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

                let tableHTML = `<table class="roster-table"><thead>`;
                
                // First header row for "Employee Name" and Dates
                tableHTML += `<tr><th class="employee-header" rowspan="2">Employee Name</th>`; // rowspan for employee header
                dates.forEach(date => {
                    // Check if the current date is a Sunday
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const headerHighlightClass = isSunday ? ' sunday-column-header' : '';
                    tableHTML += `<th class="${headerHighlightClass}">${date.getDate()}/${(date.getMonth() + 1).toString().padStart(2, '0')}</th>`;
                });
                tableHTML += `</tr>`;

                // Second header row for Day of the Week
                tableHTML += `<tr>`;
                dates.forEach(date => {
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const highlightClass = isSunday ? ' sunday-column-header' : ''; // Use header highlight for this row too
                    tableHTML += `<th class="${highlightClass}">${dayNames[date.getDay()]}</th>`;
                });
                tableHTML += `</tr></thead><tbody>`;

                // Store shift counts for summary
                const employeeShiftCounts = {};
                let totalSundaysInRosterPeriod = 0; // Initialize total Sundays for the period

                // Calculate total Sundays in the roster period (this is constant for all employees)
                dates.forEach(date => {
                    if (date.getDay() === 0) { // 0 is Sunday
                        totalSundaysInRosterPeriod++;
                    }
                });


                // Add rows for each employee
                employees.forEach((employeeName, empIndex) => {
                    employeeShiftCounts[employeeName] = { 
                        D: 0, 
                        N: 0, 
                        O: 0, 
                        normalHours: 0,
                        totalSundays: totalSundaysInRosterPeriod, // Add total Sundays
                        sundayHoursTimeAndAHalf: totalSundaysInRosterPeriod * 18 // Calculate Sunday hours (12 hours * 1.5)
                    }; 
                    tableHTML += `<tr><td class="employee-name">${employeeName}</td>`;
                    dates.forEach(date => {
                        const diffTime = Math.abs(date.getTime() - startDate.getTime());
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        const dayIndexInCycle = diffDays % 9;

                        const shift = getShiftType(dayIndexInCycle);
                        const isSunday = date.getDay() === 0; // 0 is Sunday
                        const cellHighlightClass = isSunday ? ' sunday-column-cell' : ''; // Apply cell highlight for data cells
                        tableHTML += `<td class="${cellHighlightClass}">${shift}</td>`;
                        
                        // Increment shift count for the employee
                        employeeShiftCounts[employeeName][shift]++;
                    });
                    // Calculate normal hours after all shifts for the employee are counted
                    employeeShiftCounts[employeeName].normalHours = (employeeShiftCounts[employeeName].D + employeeShiftCounts[employeeName].N + employeeShiftCounts[employeeName].O) * 12;
                    tableHTML += `</tr>`;
                });

                tableHTML += `</tbody></table>`;
                rosterOutputDiv.innerHTML = tableHTML;
                rosterOutputDiv.classList.remove('hidden');

                // Apply descriptions if already generated
                applyShiftDescriptions();

                // Generate and display summary table
                let summaryHTML = `<table class="summary-table"><thead><tr><th>Employee Name</th><th>Total Day Shifts (D)</th><th>Total Night Shifts (N)</th><th>Total Off Days (O)</th><th>Normal Hours Total</th><th>Total Sundays</th><th>Sunday Hours Time and a Half</th></tr></thead><tbody>`;
                for (const employeeName in employeeShiftCounts) {
                    const counts = employeeShiftCounts[employeeName];
                    summaryHTML += `<tr><td>${employeeName}</td><td>${counts.D}</td><td>${counts.N}</td><td>${counts.O}</td><td>${counts.normalHours}</td><td>${counts.totalSundays}</td><td>${counts.sundayHoursTimeAndAHalf}</td></tr>`;
                }
                summaryHTML += `</tbody></table>`;
                summaryTableContainer.innerHTML = summaryHTML;
                rosterSummaryDiv.classList.remove('hidden'); // Show the summary div

                showMessage('Roster generated successfully!', 'success');
            }

            /**
             * Clears the generated roster and input fields.
             */
            function clearRoster() {
                rosterOutputDiv.innerHTML = '';
                rosterOutputDiv.classList.add('hidden');
                rosterSummaryDiv.classList.add('hidden'); // Hide summary div
                summaryTableContainer.innerHTML = ''; // Clear summary content
                // Set date inputs to blank
                startDateInput.value = '';
                endDateInput.value = '';
                employeesTextarea.value = '';
                shiftDescriptions = null; // Clear cached descriptions
                hideMessage();
                showMessage('Roster cleared.', 'info');
            }

            /**
             * Exports the generated roster table to a CSV file.
             */
            function exportRosterToCSV() {
                const table = rosterOutputDiv.querySelector('table');
                if (!table) {
                    showMessage('No roster generated yet to export!', 'error');
                    return;
                }

                let csv = [];
                const rows = table.querySelectorAll('tr');

                // Manually construct CSV to include both header rows
                const headerRow1 = [];
                const headerRow2 = [];

                // Get headers from the first two rows of the table
                const headerCells1 = rows[0].querySelectorAll('th');
                const headerCells2 = rows[1].querySelectorAll('th');

                // First header row (Employee Name and Dates)
                headerCells1.forEach((cell, index) => {
                    let text = cell.innerText.trim();
                    if (index === 0) { // Employee Name cell
                        headerRow1.push(text);
                        headerRow2.push(''); // Empty cell for day of week under Employee Name
                    } else {
                        if (text.includes(',')) text = `"${text.replace(/"/g, '""')}"`;
                        headerRow1.push(text);
                    }
                });
                csv.push(headerRow1.join(','));

                // Second header row (Day of the Week)
                headerCells2.forEach(cell => {
                    let text = cell.innerText.trim();
                    if (text.includes(',')) text = `"${text.replace(/"/g, '""')}"`;
                    headerRow2.push(text);
                });
                csv.push(headerRow2.join(','));


                // Iterate over data rows (starting from index 2, as 0 and 1 are headers)
                for (let i = 2; i < rows.length; i++) {
                    const row = rows[i];
                    const cols = row.querySelectorAll('td');
                    const rowData = [];
                    cols.forEach(col => {
                        let text = col.innerText.trim();
                        if (text.includes(',')) {
                            text = `"${text.replace(/"/g, '""')}"`;
                        }
                        rowData.push(text);
                    });
                    csv.push(rowData.join(','));
                }

                // Add summary data to CSV
                const summaryTable = summaryTableContainer.querySelector('table');
                if (summaryTable) {
                    csv.push('\n'); // Add a blank line for separation
                    csv.push('Roster Summary'); // Add a header for the summary section

                    const summaryRows = summaryTable.querySelectorAll('tr');
                    summaryRows.forEach(sRow => {
                        const sCols = sRow.querySelectorAll('th, td');
                        const sRowData = [];
                        sCols.forEach(sCol => {
                            let sText = sCol.innerText.trim();
                            if (sText.includes(',')) {
                                sText = `"${sText.replace(/"/g, '""')}"`;
                            }
                            sRowData.push(sText);
                        });
                        csv.push(sRowData.join(','));
                    });
                }


                const csvString = csv.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', 'control_room_roster.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                showMessage('Roster exported to CSV!', 'success');
            }

            /**
             * Calls the Gemini API to get shift descriptions.
             */
            async function generateShiftInsights() {
                showMessage('Generating shift insights... Please wait.', 'info');
                try {
                    const prompt = "You are a helpful assistant for a control room. Provide a very concise, single-sentence description for each of the following shift types: 'D' for Day Shift, 'N' for Night Shift, and 'O' for Off Day. Focus on typical duties or status for a control room environment. Format your response as a JSON object with keys 'D', 'N', 'O' and their corresponding descriptions as values. Example: { \"D\": \"Description for Day Shift\", \"N\": \"Description for Night Shift\", \"O\": \"Description for Off Day\" }";
                    
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "D": { "type": "STRING" },
                                    "N": { "type": "STRING" },
                                    "O": { "type": "STRING" }
                                },
                                "propertyOrdering": ["D", "N", "O"]
                            }
                        }
                    };

                    const apiKey = ""; // Canvas will automatically provide this in runtime
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        try {
                            shiftDescriptions = JSON.parse(jsonText);
                            showMessage('Shift insights generated successfully! Hover over shifts to see descriptions.', 'success');
                            // If roster is already generated, apply descriptions immediately
                            if (!rosterOutputDiv.classList.contains('hidden')) {
                                applyShiftDescriptions();
                            }
                        } catch (parseError) {
                            console.error('Failed to parse LLM response:', parseError);
                            showMessage('Failed to parse shift insights. Unexpected format from AI.', 'error');
                            shiftDescriptions = null;
                        }
                    } else {
                        showMessage('No shift insights received from AI. Please try again.', 'error');
                        shiftDescriptions = null;
                    }

                } catch (error) {
                    console.error('Error generating shift insights:', error);
                    showMessage(`Error generating shift insights: ${error.message}`, 'error');
                    shiftDescriptions = null;
                }
            }

            // Event Listeners
            generateRosterBtn.addEventListener('click', generateRoster);
            exportCsvBtn.addEventListener('click', exportRosterToCSV);
            generateShiftInsightsBtn.addEventListener('click', generateShiftInsights); // Attach LLM function
            clearRosterBtn.addEventListener('click', clearRoster);
        });
    </script>
</body>
</html>
