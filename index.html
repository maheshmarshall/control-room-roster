<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Room Roster Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general layout */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Dark slate gray text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            background-color: #ffffff; /* White container background */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 30px;
            width: 100%;
            max-width: 1200px; /* Max width for larger screens */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #1e293b; /* Darker title */
            text-align: center;
            margin-bottom: 20px;
            font-weight: 700; /* Bold font */
        }
        .input-group label {
            font-weight: 600; /* Semi-bold label */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input[type="date"],
        .input-group textarea,
        .input-group select,
        .input-group input[type="text"] { /* Added text input for styling */
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 8px; /* Slightly rounded inputs */
            background-color: #f8fafc; /* Lighter input background */
            transition: all 0.2s ease-in-out;
        }
        .input-group input[type="date"]:focus,
        .input-group textarea:focus,
        .input-group select:focus,
        .input-group input[type="text"]:focus { /* Added text input for styling */
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Soft focus shadow */
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: #4f46e5; /* Indigo button */
            color: white;
            border: none;
        }
        .btn:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-1px); /* Slight lift effect */
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray button */
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        .roster-output {
            overflow-x: auto; /* Enable horizontal scrolling for the table */
            margin-top: 20px;
            border: 1px solid #e2e8f0; /* Light border around roster */
            border-radius: 8px;
        }
        .roster-table {
            width: 100%;
            border-collapse: collapse; /* Collapse table borders */
            min-width: 800px; /* Ensure minimum width for scrolling */
            margin-bottom: 20px; /* Space between multiple tables */
        }
        .roster-table th,
        .roster-table td {
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e2e8f0; /* Cell borders */
            white-space: nowrap; /* Prevent date/shift wrapping */
        }
        .roster-table thead th {
            background-color: #e0e7ff; /* Light indigo header */
            font-weight: 700;
            color: #374151;
            position: sticky; /* Sticky header for scrolling */
            top: 0;
            z-index: 10;
        }
        .roster-table tbody tr:nth-child(even) {
            background-color: #f8fafc; /* Zebra striping */
        }
        .roster-table tbody tr:hover {
            background-color: #eff6ff; /* Highlight row on hover */
        }
        .roster-table td:first-child {
            text-align: left; /* Align employee names to left */
            font-weight: 500;
            background-color: #e0e7ff; /* Light indigo for employee column */
            position: sticky; /* Sticky first column */
            left: 0;
            z-index: 10;
        }
        /* Adjust sticky header background for the first column */
        .roster-table th:first-child {
            background-color: #c7d2fe; /* Darker indigo for sticky corner */
            z-index: 11; /* Ensure it's above other sticky elements */
        }
        
        /* Message box styling */
        .message-box {
            background-color: #fff3cd; /* Light yellow background */
            border: 1px solid #ffeeba; /* Yellow border */
            color: #664d03; /* Dark yellow text */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            display: none; /* Hidden by default */
        }
        .message-box.show {
            display: block;
        }

        /* Sunday Highlight Styles */
        .sunday-column-header {
            background-color: #fecaca; /* Lighter red for header */
            color: #dc2626; /* Red text */
            font-weight: 700;
        }
        .sunday-column-cell {
            background-color: #fee2e2; /* Lightest red for data cells */
            color: #b91c1c; /* Darker red text */
        }

        /* Public Holiday Highlight Styles */
        .public-holiday-column-header {
            background-color: #fef3c7; /* Light orange/yellow for header */
            color: #d97706; /* Darker orange/yellow text */
            font-weight: 700;
        }
        .public-holiday-column-cell {
            background-color: #fefce8; /* Lightest orange/yellow for data cells */
            color: #b45309; /* Darker orange/yellow text */
        }

        /* Roster Summary Styles */
        .roster-summary {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0f9ff; /* Light blue background */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .roster-summary h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 15px;
            text-align: center;
        }
        .summary-table-container { /* New class for scrollability */
            overflow-x: auto;
            border-radius: 12px; /* Inherit border-radius from parent */
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px; /* Ensure minimum width for scrolling */
        }
        .summary-table th,
        .summary-table td {
            padding: 10px 15px;
            border: 1px solid #e2e8f0;
            text-align: left;
        }
        .summary-table thead th {
            background-color: #dbeafe; /* Lighter blue header */
            font-weight: 600;
            color: #1e40af;
        }
        .summary-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .summary-table tbody tr:hover {
            background-color: #e0f2fe;
        }
        /* Center calculation columns */
        .summary-table td:last-child,
        .summary-table td:nth-last-child(2),
        .summary-table td:nth-last-child(3),
        .summary-table td:nth-last-child(4),
        .summary-table td:nth-last-child(5), /* New: Extra Pay columns */
        .summary-table td:nth-last-child(6),
        .summary-table td:nth-last-child(7),
        .summary-table td:nth-last-child(8),
        .summary-table td:nth-last-child(9),
        .summary-table td:nth-last-child(10), /* Added for 'normal time' */
        .summary-table td:nth-last-child(11), /* Added for 'Normal Hours' */
        .summary-table td:nth-last-child(12), /* Added for 'Night Shift (Total)' */
        .summary-table td:nth-last-child(13), /* Added for 'Day&Night' */
        .summary-table td:nth-last-child(14), /* Added for 'Sunday Night' */
        .summary-table td:nth-last-child(15), /* Added for 'Sunday Day' */
        .summary-table td:nth-last-child(16), /* Added for 'Sunday Hours' Time and a half' */
        .summary-table td:nth-last-child(17) { /* Added for 'Sundays Worked' */
            text-align: center;
            font-weight: 500;
        }

        /* Leave Type Styling */
        .leave-cell {
            font-weight: 600;
            color: white; /* Default text color for leave */
        }
        .leave-annual-leave { /* Corrected class name */
            background-color: #34d399; /* Green for Annual Leave ( Tailwind green-500) */
        }
        .leave-sick-leave { /* Corrected class name */
            background-color: #facc15; /* Yellow for Sick Leave (Tailwind yellow-400) */
            color: #334155; /* Dark text for readability on yellow */
        }
        .leave-family-responsibility { /* Corrected class name */
            background-color: #f97316; /* Orange for Family Responsibility (Tailwind orange-500) */
        }
        .leave-unpaid-leave { /* Corrected class name */
            background-color: #ef4444; /* Red for Unpaid Leave (Tailwind red-500) */
        }
        .leave-info {
            background-color: #60a5fa; /* Blue for general info/tooltip */
        }

        /* Extra Pay Styling */
        .extra-pay-cell {
            font-weight: 600;
            color: white;
            background-color: #a78bfa; /* Purple for general extra pay (Tailwind purple-400) */
        }
        .extra-pay-day-overtime {
            background-color: #818cf8; /* Light Blue/Indigo for Day OT (Tailwind indigo-400) */
        }
        .extra-pay-night-overtime {
            background-color: #4c1d95; /* Darker Purple for Night OT (Tailwind violet-800) */
        }
        .extra-pay-public-holiday-day-shift {
            background-color: #22c55e; /* Bright Green for PH Day (Tailwind green-500) */
        }
        .extra-pay-public-holiday-night-shift {
            background-color: #16a34a; /* Dark Green for PH Night (Tailwind green-700) */
        }
        .extra-pay-one-normal-time-and-one-o-t-2 {
            background-color: #ec4899; /* Pink for OT2 (Tailwind pink-500) */
        }
        /* New extra pay types */
        .extra-pay-night-to-day { /* Changed from Day&Night */
            background-color: #a855f7; /* Violet for Night to Day (Tailwind violet-500) */
        }
        .extra-pay-day-to-night { /* New: Day to Night */
            background-color: #f9a8d4; /* Light pink for Day to Night */
        }

        /* Dynamic row styling */
        .dynamic-input-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto; /* 3 columns for inputs, 1 for button */
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: end; /* Align items to the bottom */
        }
        .dynamic-input-row .input-group {
            margin-bottom: 0; /* Remove default margin from input-group */
        }
        .dynamic-input-row .remove-btn {
            padding: 10px 12px;
            background-color: #ef4444; /* Red */
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            height: 42px; /* Match input height */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dynamic-input-row .remove-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
        /* Styling for LLM loading indicator */
        .loading-indicator {
            display: none; /* Hidden by default */
            margin-top: 20px;
            text-align: center;
            font-size: 1.1rem;
            color: #4f46e5;
            font-weight: 600;
        }
        .loading-indicator.show {
            display: block;
        }
        /* Flex container for date input and indicator */
        .date-input-container {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between input and indicator */
        }
        .holiday-indicator {
            color: #dc2626; /* Red color for PH text */
            font-weight: 600;
            font-size: 0.875rem; /* text-sm */
        }
    </style>
</head>
<body class="selection:bg-indigo-300">
    <div class="container">
        <h1 class="text-3xl sm:text-4xl">Control Room Roster Generator</h1>

        <div class="input-section grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="input-group">
                <label for="startDate">Roster Start Date:</label>
                <div class="date-input-container">
                    <input type="date" id="startDate" class="form-input" min="" max="">
                    <span id="startDateHolidayIndicator" class="holiday-indicator hidden">PH</span>
                </div>
            </div>
            <div class="input-group">
                <label for="endDate">Roster End Date:</label>
                <div class="date-input-container">
                    <input type="date" id="endDate" class="form-input" min="" max="">
                    <span id="endDateHolidayIndicator" class="holiday-indicator hidden">PH</span>
                </div>
            </div>
        </div>

        <div class="input-section grid grid-cols-1 md:grid-cols-3 gap-6 mt-6"> <!-- New section for shifts -->
            <div class="input-group">
                <label for="employeesA">Shift A Employees (One per line):</label>
                <textarea id="employeesA" rows="8" placeholder="Enter Shift A employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesB">Shift B Employees (One per line):</label>
                <textarea id="employeesB" rows="8" placeholder="Enter Shift B employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesC">Shift C Employees (One per line):</label>
                <textarea id="employeesC" rows="8" placeholder="Enter Shift C employee names here..." class="form-textarea"></textarea>
            </div>
        </div>

        <!-- Shift Pattern Input Section -->
        <div class="input-section grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
            <div class="input-group">
                <label for="patternA">Shift A Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternA" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
            <div class="input-group">
                <label for="patternB">Shift B Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternB" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
            <div class="input-group">
                <label for="patternC">Shift C Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternC" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
        </div>

        <div class="button-group">
            <button id="generateRosterBtn" class="btn">Generate Roster</button>
            <button id="exportCsvBtn" class="btn">Export to CSV</button>
            <button id="generateShiftInsightsBtn" class="btn">Generate Shift Insights ✨</button> <!-- New LLM Button -->
            <button id="clearRosterBtn" class="btn btn-secondary">Clear Roster</button>
        </div>

        <div id="messageBox" class="message-box"></div>
        <div id="loadingIndicator" class="loading-indicator">Generating insights...</div>


        <!-- Leave Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Leave Management</h2>
            <div id="leaveInputsContainer">
                <!-- Dynamic leave input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addLeaveEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Leave Entry</button>
                <button id="applyAllLeaveBtn" class="btn bg-blue-500 hover:bg-blue-700 text-white">Apply All Leave</button>
            </div>
            <div id="leaveCountOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Leave Counts:</h3>
                <ul id="leaveCountsList" class="list-disc pl-5"></ul>
            </div>
        </div>

        <!-- Extra Pay Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Extra Pay Management</h2>
            <div id="extraPayInputsContainer">
                <!-- Dynamic extra pay input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addExtraPayEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Extra Pay Entry</button>
                <button id="applyAllExtraPayBtn" class="btn bg-purple-500 hover:bg-purple-700 text-white">Apply All Extra Pay</button>
            </div>
            <div id="extraPayOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Extra Pay Details:</h3>
                <ul id="extraPayList" class="list-disc pl-5"></ul>
            </div>
        </div>


        <div id="rosterOutput" class="roster-output hidden">
            <!-- Roster table(s) will be generated here -->
        </div>

        <div id="rosterSummary" class="roster-summary hidden">
            <h2>Roster Summary</h2>
            <div id="summaryTableContainer" class="summary-table-container">
                <!-- Summary table will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variable to store shift descriptions from LLM
        let shiftDescriptions = null;

        // Global variables to store leave data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Leave Type" } }
        let employeeLeaveData = {};
        // Example: { "Employee Name": { "annual leave": 5, "sick leave": 2 } }
        let employeeLeaveCounts = {};

        // Global variable to store extra pay data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Extra Pay Type" } }
        let employeeExtraPayData = {};

        // Define all possible extra pay types for summary table columns
        const ALL_EXTRA_PAY_TYPES = [
            'day overtime',
            'night overtime',
            'public holiday day shift',
            'public holiday night shift',
            'one normal time and one o/t 2',
            'night to day', // Changed from 'Day&Night'
            'day to night' // Added new extra pay type
        ];

        // Define all possible leave types
        const ALL_LEAVE_TYPES = [
            'annual leave',
            'sick leave',
            'family responsibility',
            'unpaid leave'
        ];

        // South African Public Holidays (YYYY-MM-DD format) - Observed dates
        const SOUTH_AFRICAN_PUBLIC_HOLIDAYS = new Set([
            // 2025
            '2025-01-01', // New Year's Day
            '2025-03-21', // Human Rights Day
            '2025-04-18', // Good Friday
            '2025-04-21', // Family Day
            '2025-04-28', // Freedom Day (Observed, since 27th is Sunday)
            '2025-05-01', // Workers' Day
            '2025-06-16', // Youth Day
            '2025-08-11', // National Women's Day (Observed, since 9th is Saturday)
            '2025-09-24', // Heritage Day
            '2025-12-16', // Day of Reconciliation
            '2025-12-25', // Christmas Day
            '2025-12-26', // Day of Goodwill
            // 2026
            '2026-01-01', // New Year's Day
            '2026-03-23', // Human Rights Day (Observed, since 21st is Saturday)
            '2026-04-03', // Good Friday
            '2026-04-06', // Family Day
            '2026-04-27', // Freedom Day
            '2026-05-01', // Workers' Day
            '2026-06-16', // Youth Day
            '2026-08-10', // National Women's Day (Observed, since 9th is Sunday)
            '2026-09-24', // Heritage Day
            '2026-12-16', // Day of Reconciliation
            '2026-12-25', // Christmas Day
            '2026-12-26'  // Day of Goodwill
        ]);

        /**
         * Checks if a given date string is a South African public holiday.
         * @param {string} dateString - The date string in YYYY-MM-DD format.
         * @returns {boolean} True if it's a public holiday, false otherwise.
         */
        function isPublicHoliday(dateString) {
            return SOUTH_AFRICAN_PUBLIC_HOLIDAYS.has(dateString);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const employeesATextarea = document.getElementById('employeesA');
            const employeesBTextarea = document.getElementById('employeesB');
            const employeesCTextarea = document.getElementById('employeesC');
            // New shift pattern inputs
            const patternAInput = document.getElementById('patternA');
            const patternBInput = document.getElementById('patternB');
            const patternCInput = document.getElementById('patternC');

            const generateRosterBtn = document.getElementById('generateRosterBtn');
            const exportCsvBtn = document.getElementById('exportCsvBtn');
            const generateShiftInsightsBtn = document.getElementById('generateShiftInsightsBtn'); // New: LLM Button
            const clearRosterBtn = document.getElementById('clearRosterBtn');
            const rosterOutputDiv = document.getElementById('rosterOutput');
            const messageBox = document.getElementById('messageBox');
            const loadingIndicator = document.getElementById('loadingIndicator'); // LLM loading indicator
            const rosterSummaryDiv = document.getElementById('rosterSummary');
            const summaryTableContainer = document.getElementById('summaryTableContainer');

            // Leave Management DOM elements
            const leaveInputsContainer = document.getElementById('leaveInputsContainer');
            const addLeaveEntryBtn = document.getElementById('addLeaveEntryBtn');
            const applyAllLeaveBtn = document.getElementById('applyAllLeaveBtn');
            const leaveCountOutput = document.getElementById('leaveCountOutput');
            const leaveCountsList = document.getElementById('leaveCountsList');

            // Extra Pay Management DOM elements
            const extraPayInputsContainer = document.getElementById('extraPayInputsContainer');
            const addExtraPayEntryBtn = document.getElementById('addExtraPayEntryBtn');
            const applyAllExtraPayBtn = document.getElementById('applyAllExtraPayBtn');
            const extraPayOutput = document.getElementById('extraPayOutput');
            const extraPayList = document.getElementById('extraPayList');

            // Holiday indicators
            const startDateHolidayIndicator = document.getElementById('startDateHolidayIndicator');
            const endDateHolidayIndicator = document.getElementById('endDateHolidayIndicator');


            // Set min date to 2025-01-01
            const overallMinDate = `2025-01-01`;
            // Max date is December 31st of 2030
            const overallMaxDate = `2030-12-31`;

            startDateInput.setAttribute('min', overallMinDate);
            startDateInput.setAttribute('max', overallMaxDate);
            endDateInput.setAttribute('min', overallMinDate);
            endDateInput.setAttribute('max', overallMaxDate);

            // Set employee textareas to be blank by default
            employeesATextarea.value = '';
            employeesBTextarea.value = '';
            employeesCTextarea.value = '';

            /**
             * Helper function to parse a YYYY-MM-DD string into a Date object in local time.
             * @param {string} dateString - The date string in YYYY-MM-DD format.
             * @returns {Date} A Date object representing the date in local time.
             */
            function parseDateString(dateString) {
                const [year, month, day] = dateString.split('-').map(Number);
                // Month is 0-indexed in JavaScript Date constructor
                return new Date(year, month - 1, day);
            }

            /**
             * Helper function to format a Date object into a YYYY-MM-DD string in local time.
             * @param {Date} date - The Date object to format.
             * @returns {string} The date string in YYYY-MM-DD format.
             */
            function formatDateToYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
                const day = date.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            /**
             * Updates the public holiday indicator next to a date input.
             * @param {HTMLInputElement} dateInput - The date input element.
             * @param {HTMLElement} indicatorSpan - The span element for the indicator.
             */
            function updateDateInputHolidayIndicator(dateInput, indicatorSpan) {
                if (dateInput.value && isPublicHoliday(dateInput.value)) {
                    indicatorSpan.classList.remove('hidden');
                } else {
                    indicatorSpan.classList.add('hidden');
                }
            }

            // Event listener to ensure endDate is not before startDate
            startDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        // Adjust endDate to be a reasonable date after startDate, e.g., 15th of next month
                        const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                        endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                        showMessage('End date adjusted to be after start date.', 'info');
                    }
                } else if (startDateInput.value && !endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                    endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                }
                endDateInput.setAttribute('min', startDateInput.value);
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
                updateDateInputHolidayIndicator(startDateInput, startDateHolidayIndicator);
            });

            endDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        showMessage('End date cannot be before start date. Please correct.', 'error');
                        endDateInput.value = '';
                    }
                }
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
                updateDateInputHolidayIndicator(endDateInput, endDateHolidayIndicator);
            });

            /**
             * Updates the min/max attributes for date inputs in dynamic rows.
             */
            function updateDynamicRowDateConstraints() {
                const minDate = startDateInput.value;
                const maxDate = endDateInput.value;

                document.querySelectorAll('.dynamic-input-row input[type="date"]').forEach(input => {
                    input.setAttribute('min', minDate);
                    input.setAttribute('max', maxDate);
                });
            }


            /**
             * Displays a message in the message box.
             * @param {string} message - The message to display.
             * @param {string} type - The type of message (e.g., 'error', 'info', 'success', 'warning').
             */
            function showMessage(message, type = 'info') {
                messageBox.textContent = message;
                messageBox.className = 'message-box show';
                // Clear previous type classes
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                
                if (type === 'error') {
                    messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
                } else if (type === 'success') {
                    messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
                } else if (type === 'warning') {
                    messageBox.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                } else {
                    messageBox.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
                }
                setTimeout(() => {
                    hideMessage();
                }, 5000);
            }

            /**
             * Hides the message box.
             */
            function hideMessage() {
                messageBox.className = 'message-box';
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
            }


            /**
             * Determines the shift type (D, N, O) based on the day's index within the cycle and the provided pattern.
             * @param {number} dayIndexInCycle - The 0-indexed day within the cycle.
             * @param {string} pattern - The shift pattern (e.g., "DDDNNNOOO").
             * @returns {string} The shift type ('D', 'N', or 'O').
             */
            function getShiftType(dayIndexInCycle, pattern) {
                // Ensure pattern is valid and has expected length
                const patternLength = pattern.length;
                if (!pattern || patternLength === 0 || !/^[DNO]+$/.test(pattern)) {
                    // Fallback to a default 9-day pattern if invalid
                    return ["D", "D", "D", "N", "N", "N", "O", "O", "O"][dayIndexInCycle % 9];
                }
                return pattern[dayIndexInCycle % patternLength];
            }

            /**
             * Applies LLM-generated shift descriptions as tooltips to the roster cells.
             */
            function applyShiftDescriptions() {
                if (!shiftDescriptions) {
                    return; // No descriptions to apply
                }
                const shiftCells = rosterOutputDiv.querySelectorAll('.roster-table tbody td');
                shiftCells.forEach(cell => {
                    // Only apply tooltip if it's a shift, not a leave or extra pay
                    if (!cell.classList.contains('leave-cell') && !cell.classList.contains('extra-pay-cell')) {
                        const shiftType = cell.textContent.trim();
                        if (shiftDescriptions[shiftType]) {
                            cell.setAttribute('title', shiftDescriptions[shiftType]);
                        }
                    }
                });
            }

            /**
             * Generates a single roster table for a given set of employees.
             * @param {Array<string>} employees - List of employee names for this shift.
             * @param {Array<Date>} dates - List of dates in the roster period.
             * @param {Object} currentEmployeeShiftCounts - Object to accumulate shift counts for all employees.
             * @param {string} shiftName - The name of the shift (e.g., "Shift A").
             * @param {string} shiftPattern - The pattern for this shift.
             * @returns {string} The HTML string for the generated roster table.
             */
            function generateSingleRosterTable(employees, dates, currentEmployeeShiftCounts, shiftName, shiftPattern) {
                // Array for short day names (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
                const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

                let tableHTML = `<h3 class="text-xl font-semibold mb-2 mt-4 text-center">${shiftName} Roster</h3>`;
                tableHTML += `<table class="roster-table"><thead>`;
                
                // First header row for "Employee Name" and Dates (DD/MM)
                tableHTML += `<tr><th class="sticky-header-corner">Employee Name</th>`;
                dates.forEach(date => {
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0; // Sunday is 0
                    const isHoliday = isPublicHoliday(dateString);
                    let headerClasses = '';
                    if (isSunday) {
                        headerClasses += ' sunday-column-header';
                    }
                    if (isHoliday) {
                        headerClasses += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${headerClasses}">${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}</th>`;
                });
                tableHTML += `</tr>`;

                // Second header row for Day Names (Mon, Tue, etc.)
                tableHTML += `<tr><th></th>`; // Empty cell for employee column
                dates.forEach(date => {
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0;
                    const isHoliday = isPublicHoliday(dateString);
                    let headerClasses = '';
                    if (isSunday) {
                        headerClasses += ' sunday-column-header';
                    }
                    if (isHoliday) {
                        headerClasses += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${headerClasses}">${dayNames[date.getDay()]}</th>`;
                });
                tableHTML += `</tr></thead><tbody>`;

                // Table Body
                employees.forEach(employee => {
                    // Initialize employee's counts if not already present
                    if (!currentEmployeeShiftCounts[employee]) {
                        currentEmployeeShiftCounts[employee] = {
                            'D': 0,
                            'N': 0,
                            'O': 0,
                            'Total Shifts': 0,
                            'normal time': 0, // New: normal time
                            'normal hours': 0, // New: normal hours
                            'night shift total': 0, // New: night shift total
                            'day & night': 0, // New: day & night (for Night to Day)
                            'sunday day': 0, // New: Sunday Day count
                            'sunday night': 0, // New: Sunday Night count
                            'sundays worked': 0, // New: Sundays Worked count
                            'sunday hours time and a half': 0 // New: Sunday Hours' Time and a half
                        };
                        ALL_LEAVE_TYPES.forEach(leaveType => currentEmployeeShiftCounts[employee][leaveType] = 0);
                        ALL_EXTRA_PAY_TYPES.forEach(extraPayType => currentEmployeeShiftCounts[employee][extraPayType] = 0);
                    }

                    tableHTML += `<tr><td class="sticky-employee-column">${employee}</td>`;
                    dates.forEach((date, dayIndex) => {
                        const dateString = formatDateToYYYYMMDD(date);
                        const dayOfWeek = date.getDay(); // 0 for Sunday, 1 for Monday
                        const isSunday = dayOfWeek === 0;
                        const isHoliday = isPublicHoliday(dateString);
                        const dayIndexInCycle = dayIndex; // This is the 0-indexed day from the start of the roster period

                        let cellContent = '';
                        let cellClasses = '';

                        // Check for leave
                        if (employeeLeaveData[employee] && employeeLeaveData[employee][dateString]) {
                            const leaveType = employeeLeaveData[employee][dateString];
                            cellContent = leaveType.split(' ').map(word => word[0].toUpperCase()).join(''); // e.g., "Annual Leave" -> "AL"
                            cellClasses += ` leave-cell leave-${leaveType.replace(/\s+/g, '-')}`;
                            currentEmployeeShiftCounts[employee][leaveType]++;
                        }
                        // Check for extra pay
                        else if (employeeExtraPayData[employee] && employeeExtraPayData[employee][dateString]) {
                            const extraPayType = employeeExtraPayData[employee][dateString];
                            cellContent = extraPayType.split(' ').map(word => word[0].toUpperCase()).join(''); // e.g., "Day Overtime" -> "DO"
                            cellClasses += ` extra-pay-cell extra-pay-${extraPayType.replace(/\s+/g, '-')}`;
                            currentEmployeeShiftCounts[employee][extraPayType]++;
                        }
                        // Otherwise, assign regular shift
                        else {
                            const baseShiftType = getShiftType(dayIndexInCycle, shiftPattern);
                            cellContent = baseShiftType;
                            currentEmployeeShiftCounts[employee][baseShiftType]++; // Increment D, N, or O count
                            currentEmployeeShiftCounts[employee]['Total Shifts']++; // Increment total shifts

                            // Specific calculations for normal time, night shift total, day & night
                            if (baseShiftType === 'D' || baseShiftType === 'N') {
                                currentEmployeeShiftCounts[employee]['normal time']++;
                            }
                            if (baseShiftType === 'N') {
                                currentEmployeeShiftCounts[employee]['night shift total']++;
                            }
                            // The 'Day&Night' column in summary is now 'Night to Day' in extra pay
                            // This means a shift that transitions from Night to Day.
                            // This is handled by the extra pay type 'night to day' and not a base shift.

                            // New: Calculate Sunday Day and Sunday Night
                            if (isSunday) {
                                if (baseShiftType === 'D') {
                                    currentEmployeeShiftCounts[employee]['sunday day']++;
                                    currentEmployeeShiftCounts[employee]['sundays worked']++; // Increment Sundays Worked
                                } else if (baseShiftType === 'N') {
                                    currentEmployeeShiftCounts[employee]['sunday night']++;
                                    currentEmployeeShiftCounts[employee]['sundays worked']++; // Increment Sundays Worked
                                }
                            }
                        }

                        // Apply Sunday/Public Holiday highlighting to cell
                        if (isSunday) {
                            cellClasses += ' sunday-column-cell';
                        }
                        if (isHoliday) {
                            cellClasses += ' public-holiday-column-cell';
                        }

                        tableHTML += `<td class="${cellClasses}">${cellContent}</td>`;
                    });
                    tableHTML += `</tr>`;
                });
                tableHTML += `</tbody></table>`;
                return tableHTML;
            }

            /**
             * Generates the main roster and summary.
             */
            function generateRoster() {
                const startDateStr = startDateInput.value;
                const endDateStr = endDateInput.value;
                const employeesA = employeesATextarea.value.split('\n').map(name => name.trim()).filter(name => name);
                const employeesB = employeesBTextarea.value.split('\n').map(name => name.trim()).filter(name => name);
                const employeesC = employeesCTextarea.value.split('\n').map(name => name.trim()).filter(name => name);
                const patternA = patternAInput.value.trim().toUpperCase();
                const patternB = patternBInput.value.trim().toUpperCase();
                const patternC = patternCInput.value.trim().toUpperCase();

                if (!startDateStr || !endDateStr) {
                    showMessage('Please select both start and end dates.', 'error');
                    return;
                }
                if (employeesA.length === 0 && employeesB.length === 0 && employeesC.length === 0) {
                    showMessage('Please enter employees for at least one shift.', 'error');
                    return;
                }

                const startDate = parseDateString(startDateStr);
                const endDate = parseDateString(endDateStr);

                if (startDate > endDate) {
                    showMessage('Start date cannot be after end date.', 'error');
                    return;
                }

                const dates = [];
                let currentDate = new Date(startDate);
                while (currentDate <= endDate) {
                    dates.push(new Date(currentDate)); // Push a copy
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                let allRosterHTML = '';
                // This object will accumulate counts for all employees across all shifts
                let allEmployeeShiftCounts = {};

                if (employeesA.length > 0) {
                    allRosterHTML += generateSingleRosterTable(employeesA, dates, allEmployeeShiftCounts, "Shift A", patternA);
                }
                if (employeesB.length > 0) {
                    allRosterHTML += generateSingleRosterTable(employeesB, dates, allEmployeeShiftCounts, "Shift B", patternB);
                }
                if (employeesC.length > 0) {
                    allRosterHTML += generateSingleRosterTable(employeesC, dates, allEmployeeShiftCounts, "Shift C", patternC);
                }

                rosterOutputDiv.innerHTML = allRosterHTML;
                rosterOutputDiv.classList.remove('hidden');
                exportCsvBtn.classList.remove('hidden');
                generateShiftInsightsBtn.classList.remove('hidden'); // Ensure LLM button is visible after roster generation
                clearRosterBtn.classList.remove('hidden');

                // Generate and display summary
                generateRosterSummary(allEmployeeShiftCounts);

                // Apply LLM descriptions if available
                applyShiftDescriptions();
                showMessage('Roster generated successfully!', 'success');
            }

            /**
             * Generates and displays the roster summary table.
             * @param {Object} allEmployeeShiftCounts - The accumulated shift counts for all employees.
             */
            function generateRosterSummary(allEmployeeShiftCounts) {
                if (Object.keys(allEmployeeShiftCounts).length === 0) {
                    rosterSummaryDiv.classList.add('hidden');
                    return;
                }

                let summaryHTML = `<table class="summary-table"><thead><tr>`;
                summaryHTML += `<th>Employee Name</th>`;
                summaryHTML += `<th>Day Shifts (D)</th>`;
                summaryHTML += `<th>Night Shifts (N)</th>`;
                summaryHTML += `<th>Off Days (O)</th>`;
                summaryHTML += `<th>Total Shifts</th>`;
                summaryHTML += `<th>Normal Time</th>`; // Existing column
                summaryHTML += `<th>Normal Hours</th>`; // New column

                // New Sunday columns, placed before Sunday Day/Night
                summaryHTML += `<th>Sundays Worked</th>`; // New column
                summaryHTML += `<th>Sunday Hours' Time and a half</th>`; // New column

                summaryHTML += `<th>Sunday Day</th>`; // Existing column
                summaryHTML += `<th>Sunday Night</th>`; // Existing column
                summaryHTML += `<th>Night Shift (Total)</th>`; // Existing column
                summaryHTML += `<th>Day & Night</th>`; // Existing column (for Night to Day extra pay)
                

                // Add headers for all leave types
                ALL_LEAVE_TYPES.forEach(leaveType => {
                    summaryHTML += `<th>${leaveType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}</th>`;
                });

                // Add headers for all extra pay types
                ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                    summaryHTML += `<th>${extraPayType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}</th>`;
                });

                summaryHTML += `</tr></thead><tbody>`;

                for (const employee in allEmployeeShiftCounts) {
                    const counts = allEmployeeShiftCounts[employee];
                    const normalTime = counts['normal time'] || 0;
                    const normalHours = normalTime * 12; // Calculate Normal Hours
                    const sundaysWorked = counts['sundays worked'] || 0; // Get Sundays Worked count
                    const sundayHoursTimeAndAHalf = sundaysWorked * 18; // Calculate Sunday Hours' Time and a half

                    summaryHTML += `<tr><td>${employee}</td>`;
                    summaryHTML += `<td>${counts['D'] || 0}</td>`;
                    summaryHTML += `<td>${counts['N'] || 0}</td>`;
                    summaryHTML += `<td>${counts['O'] || 0}</td>`;
                    summaryHTML += `<td>${counts['Total Shifts'] || 0}</td>`;
                    summaryHTML += `<td>${normalTime}</td>`; // Display Normal Time
                    summaryHTML += `<td>${normalHours}</td>`; // Display Normal Hours

                    // Display new Sunday columns
                    summaryHTML += `<td>${sundaysWorked}</td>`;
                    summaryHTML += `<td>${sundayHoursTimeAndAHalf}</td>`;

                    summaryHTML += `<td>${counts['sunday day'] || 0}</td>`; // Display Sunday Day count
                    summaryHTML += `<td>${counts['sunday night'] || 0}</td>`; // Display Sunday Night count
                    summaryHTML += `<td>${counts['night shift total'] || 0}</td>`; // Display night shift total
                    summaryHTML += `<td>${counts['night to day'] || 0}</td>`; // Display 'Night to Day' (from extra pay)
                    

                    // Display counts for all leave types
                    ALL_LEAVE_TYPES.forEach(leaveType => {
                        summaryHTML += `<td>${counts[leaveType] || 0}</td>`;
                    });

                    // Display counts for all extra pay types
                    ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                        summaryHTML += `<td>${counts[extraPayType] || 0}</td>`;
                    });

                    summaryHTML += `</tr>`;
                }
                summaryHTML += `</tbody></table>`;

                summaryTableContainer.innerHTML = summaryHTML;
                rosterSummaryDiv.classList.remove('hidden');
            }

            /**
             * Exports the generated roster data to a CSV file.
             */
            function exportRosterToCsv() {
                const rosterTables = rosterOutputDiv.querySelectorAll('.roster-table');
                if (rosterTables.length === 0) {
                    showMessage('No roster to export. Please generate a roster first.', 'warning');
                    return;
                }

                let csvContent = "";

                rosterTables.forEach(table => {
                    const shiftName = table.previousElementSibling ? table.previousElementSibling.textContent.replace(' Roster', '') : 'Roster';
                    csvContent += `${shiftName}\n`;

                    const headers = [];
                    table.querySelectorAll('thead tr:first-child th').forEach(th => {
                        headers.push(th.textContent.trim());
                    });
                    csvContent += headers.join(',') + '\n';

                    const dayHeaders = [];
                    table.querySelectorAll('thead tr:last-child th').forEach(th => {
                        dayHeaders.push(th.textContent.trim());
                    });
                    csvContent += dayHeaders.join(',') + '\n';

                    table.querySelectorAll('tbody tr').forEach(row => {
                        const rowData = [];
                        row.querySelectorAll('td').forEach(cell => {
                            rowData.push(`"${cell.textContent.trim()}"`); // Enclose in quotes to handle commas
                        });
                        csvContent += rowData.join(',') + '\n';
                    });
                    csvContent += '\n'; // Add a blank line between tables
                });

                // Add summary table to CSV
                const summaryTable = summaryTableContainer.querySelector('.summary-table');
                if (summaryTable) {
                    csvContent += "Roster Summary\n";
                    const summaryHeaders = [];
                    summaryTable.querySelectorAll('thead th').forEach(th => {
                        summaryHeaders.push(th.textContent.trim());
                    });
                    csvContent += summaryHeaders.join(',') + '\n';

                    summaryTable.querySelectorAll('tbody tr').forEach(row => {
                        const rowData = [];
                        row.querySelectorAll('td').forEach(cell => {
                            rowData.push(`"${cell.textContent.trim()}"`);
                        });
                        csvContent += rowData.join(',') + '\n';
                    });
                }


                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'control_room_roster.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage('Roster exported to CSV successfully!', 'success');
            }

            /**
             * Clears all inputs and the generated roster/summary.
             */
            function clearRoster() {
                startDateInput.value = '';
                endDateInput.value = '';
                employeesATextarea.value = '';
                employeesBTextarea.value = '';
                employeesCTextarea.value = '';
                patternAInput.value = 'DDDNNNOOO';
                patternBInput.value = 'DDDNNNOOO';
                patternCInput.value = 'DDDNNNOOO';

                rosterOutputDiv.innerHTML = '';
                rosterOutputDiv.classList.add('hidden');
                rosterSummaryDiv.innerHTML = '';
                rosterSummaryDiv.classList.add('hidden');
                exportCsvBtn.classList.add('hidden');
                generateShiftInsightsBtn.classList.add('hidden');
                clearRosterBtn.classList.add('hidden');
                hideMessage();

                // Clear leave and extra pay data
                employeeLeaveData = {};
                employeeLeaveCounts = {};
                employeeExtraPayData = {};
                shiftDescriptions = null; // Clear LLM descriptions

                leaveInputsContainer.innerHTML = ''; // Clear dynamic leave inputs
                extraPayInputsContainer.innerHTML = ''; // Clear dynamic extra pay inputs
                leaveCountOutput.classList.add('hidden');
                extraPayOutput.classList.add('hidden');

                // Hide holiday indicators on clear
                startDateHolidayIndicator.classList.add('hidden');
                endDateHolidayIndicator.classList.add('hidden');

                showMessage('Roster and inputs cleared.', 'info');
            }

            /**
             * Adds a new dynamic row for leave input.
             */
            function addLeaveEntryRow() {
                const newRow = document.createElement('div');
                newRow.classList.add('dynamic-input-row');
                newRow.innerHTML = `
                    <div class="input-group">
                        <label>Employee Name:</label>
                        <input type="text" class="form-input employee-name-input" placeholder="e.g., John Doe">
                    </div>
                    <div class="input-group">
                        <label>Leave Type:</label>
                        <select class="form-select leave-type-select">
                            <option value="">Select Leave Type</option>
                            <option value="annual leave">Annual Leave</option>
                            <option value="sick leave">Sick Leave</option>
                            <option value="family responsibility">Family Responsibility</option>
                            <option value="unpaid leave">Unpaid Leave</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Date (YYYY-MM-DD):</label>
                        <input type="date" class="form-input leave-date-input" min="${startDateInput.value}" max="${endDateInput.value}">
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;
                leaveInputsContainer.appendChild(newRow);

                // Add event listener to remove button
                newRow.querySelector('.remove-btn').addEventListener('click', () => {
                    newRow.remove();
                });

                // Update date constraints for the newly added row
                updateDynamicRowDateConstraints();
            }

            /**
             * Applies all leave entries from the dynamic input rows to the employeeLeaveData.
             * Then regenerates the roster.
             */
            function applyAllLeave() {
                employeeLeaveData = {}; // Clear existing leave data
                employeeLeaveCounts = {}; // Clear existing leave counts

                const leaveRows = leaveInputsContainer.querySelectorAll('.dynamic-input-row');
                let hasErrors = false;

                leaveRows.forEach(row => {
                    const employeeName = row.querySelector('.employee-name-input').value.trim();
                    const leaveType = row.querySelector('.leave-type-select').value;
                    const leaveDate = row.querySelector('.leave-date-input').value;

                    if (!employeeName || !leaveType || !leaveDate) {
                        showMessage('Please fill in all fields for each leave entry.', 'error');
                        hasErrors = true;
                        return;
                    }

                    // Check if employee exists in any shift
                    const allEmployees = [
                        ...employeesATextarea.value.split('\n').map(name => name.trim()).filter(name => name),
                        ...employeesBTextarea.value.split('\n').map(name => name.trim()).filter(name => name),
                        ...employeesCTextarea.value.split('\n').map(name => name.trim()).filter(name => name)
                    ];
                    if (!allEmployees.includes(employeeName)) {
                        showMessage(`Employee "${employeeName}" not found in any shift. Please check the name.`, 'error');
                        hasErrors = true;
                        return;
                    }

                    if (!employeeLeaveData[employeeName]) {
                        employeeLeaveData[employeeName] = {};
                    }
                    employeeLeaveData[employeeName][leaveDate] = leaveType;

                    // Update leave counts
                    if (!employeeLeaveCounts[employeeName]) {
                        employeeLeaveCounts[employeeName] = {};
                        ALL_LEAVE_TYPES.forEach(type => employeeLeaveCounts[employeeName][type] = 0);
                    }
                    employeeLeaveCounts[employeeName][leaveType]++;
                });

                if (!hasErrors) {
                    generateRoster(); // Regenerate roster with applied leave
                    renderLeaveCounts(); // Display leave counts
                    showMessage('Leave entries applied and roster regenerated.', 'success');
                }
            }

            /**
             * Renders the calculated leave counts to the UI.
             */
            function renderLeaveCounts() {
                leaveCountsList.innerHTML = '';
                if (Object.keys(employeeLeaveCounts).length === 0) {
                    leaveCountOutput.classList.add('hidden');
                    return;
                }

                for (const employee in employeeLeaveCounts) {
                    const counts = employeeLeaveCounts[employee];
                    let employeeLi = document.createElement('li');
                    employeeLi.textContent = `${employee}: `;
                    let details = [];
                    ALL_LEAVE_TYPES.forEach(type => {
                        if (counts[type] > 0) {
                            details.push(`${type.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}: ${counts[type]} days`);
                        }
                    });
                    if (details.length > 0) {
                        employeeLi.textContent += details.join(', ');
                        leaveCountsList.appendChild(employeeLi);
                    }
                }
                leaveCountOutput.classList.remove('hidden');
            }


            /**
             * Adds a new dynamic row for extra pay input.
             */
            function addExtraPayEntryRow() {
                const newRow = document.createElement('div');
                newRow.classList.add('dynamic-input-row');
                newRow.innerHTML = `
                    <div class="input-group">
                        <label>Employee Name:</label>
                        <input type="text" class="form-input employee-name-input" placeholder="e.g., Jane Doe">
                    </div>
                    <div class="input-group">
                        <label>Extra Pay Type:</label>
                        <select class="form-select extra-pay-type-select">
                            <option value="">Select Extra Pay Type</option>
                            <option value="day overtime">Day Overtime</option>
                            <option value="night overtime">Night Overtime</option>
                            <option value="public holiday day shift">Public Holiday Day Shift</option>
                            <option value="public holiday night shift">Public Holiday Night Shift</option>
                            <option value="one normal time and one o/t 2">One Normal Time and One O/T 2</option>
                            <option value="night to day">Night to Day</option>
                            <option value="day to night">Day to Night</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Date (YYYY-MM-DD):</label>
                        <input type="date" class="form-input extra-pay-date-input" min="${startDateInput.value}" max="${endDateInput.value}">
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;
                extraPayInputsContainer.appendChild(newRow);

                // Add event listener to remove button
                newRow.querySelector('.remove-btn').addEventListener('click', () => {
                    newRow.remove();
                });

                // Update date constraints for the newly added row
                updateDynamicRowDateConstraints();
            }

            /**
             * Applies all extra pay entries from the dynamic input rows to the employeeExtraPayData.
             * Then regenerates the roster.
             */
            function applyAllExtraPay() {
                employeeExtraPayData = {}; // Clear existing extra pay data

                const extraPayRows = extraPayInputsContainer.querySelectorAll('.dynamic-input-row');
                let hasErrors = false;

                extraPayRows.forEach(row => {
                    const employeeName = row.querySelector('.employee-name-input').value.trim();
                    const extraPayType = row.querySelector('.extra-pay-type-select').value;
                    const extraPayDate = row.querySelector('.extra-pay-date-input').value;

                    if (!employeeName || !extraPayType || !extraPayDate) {
                        showMessage('Please fill in all fields for each extra pay entry.', 'error');
                        hasErrors = true;
                        return;
                    }

                    // Check if employee exists in any shift
                    const allEmployees = [
                        ...employeesATextarea.value.split('\n').map(name => name.trim()).filter(name => name),
                        ...employeesBTextarea.value.split('\n').map(name => name.trim()).filter(name => name),
                        ...employeesCTextarea.value.split('\n').map(name => name.trim()).filter(name => name)
                    ];
                    if (!allEmployees.includes(employeeName)) {
                        showMessage(`Employee "${employeeName}" not found in any shift. Please check the name.`, 'error');
                        hasErrors = true;
                        return;
                    }

                    if (!employeeExtraPayData[employeeName]) {
                        employeeExtraPayData[employeeName] = {};
                    }
                    employeeExtraPayData[employeeName][extraPayDate] = extraPayType;
                });

                if (!hasErrors) {
                    generateRoster(); // Regenerate roster with applied extra pay
                    renderExtraPayDetails(); // Display extra pay details (optional, can be integrated into summary)
                    showMessage('Extra pay entries applied and roster regenerated.', 'success');
                }
            }

            /**
             * Renders the extra pay details to the UI.
             * This function is currently simple and just lists entries.
             * The main impact is on the summary table calculation.
             */
            function renderExtraPayDetails() {
                extraPayList.innerHTML = '';
                if (Object.keys(employeeExtraPayData).length === 0) {
                    extraPayOutput.classList.add('hidden');
                    return;
                }

                for (const employee in employeeExtraPayData) {
                    const datesWithExtraPay = employeeExtraPayData[employee];
                    for (const date in datesWithExtraPay) {
                        const type = datesWithExtraPay[date];
                        let li = document.createElement('li');
                        li.textContent = `${employee} on ${date}: ${type.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}`;
                        extraPayList.appendChild(li);
                    }
                }
                extraPayOutput.classList.remove('hidden');
            }


            /**
             * Calls the LLM to generate shift descriptions based on the provided patterns.
             */
            async function generateShiftInsights() {
                const patternA = patternAInput.value.trim().toUpperCase();
                const patternB = patternBInput.value.trim().toUpperCase();
                const patternC = patternCInput.value.trim().toUpperCase();

                if (!patternA && !patternB && !patternC) {
                    showMessage('Please enter at least one shift pattern to generate insights.', 'warning');
                    return;
                }

                loadingIndicator.classList.add('show');
                generateShiftInsightsBtn.disabled = true; // Disable button during loading

                const prompt = `Given the following shift patterns for a control room, provide a brief, professional description for each shift type (D, N, O). If a pattern is not provided for a shift, assume a standard 9-day cycle (DDDNNNOOO).
                Shift A Pattern: ${patternA || 'DDDNNNOOO'}
                Shift B Pattern: ${patternB || 'DDDNNNOOO'}
                Shift C Pattern: ${patternC || 'DDDNNNOOO'}

                Provide the output as a JSON object with keys 'D', 'N', 'O' and their corresponding descriptions. For example:
                {
                  "D": "Day Shift: Employees work during standard daytime hours, typically involving monitoring and routine operations.",
                  "N": "Night Shift: Employees work during nighttime hours, often handling critical alerts and maintaining continuous surveillance.",
                  "O": "Off Day: Employees are not scheduled for work, allowing for rest and personal time."
                }`;

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { 
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "D": { "type": "STRING" },
                                    "N": { "type": "STRING" },
                                    "O": { "type": "STRING" }
                                }
                            }
                        }
                    };
                    const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        shiftDescriptions = JSON.parse(jsonText);
                        showMessage('Shift insights generated successfully! Hover over shifts in the roster for descriptions.', 'success');
                        // Re-generate roster to apply new tooltips
                        generateRoster();
                    } else {
                        showMessage('Failed to generate shift insights. Please try again.', 'error');
                        console.error('LLM response structure unexpected:', result);
                    }
                } catch (error) {
                    showMessage('Error generating shift insights: ' + error.message, 'error');
                    console.error('Error calling LLM:', error);
                } finally {
                    loadingIndicator.classList.remove('show');
                    generateShiftInsightsBtn.disabled = false; // Re-enable button
                }
            }


            // Event Listeners
            generateRosterBtn.addEventListener('click', generateRoster);
            exportCsvBtn.addEventListener('click', exportRosterToCsv);
            generateShiftInsightsBtn.addEventListener('click', generateShiftInsights); // New: LLM Button listener
            clearRosterBtn.addEventListener('click', clearRoster);
            addLeaveEntryBtn.addEventListener('click', addLeaveEntryRow);
            applyAllLeaveBtn.addEventListener('click', applyAllLeave);
            addExtraPayEntryBtn.addEventListener('click', addExtraPayEntryRow);
            applyAllExtraPayBtn.addEventListener('click', applyAllExtraPay);

            // Initial state adjustments
            exportCsvBtn.classList.add('hidden');
            generateShiftInsightsBtn.classList.add('hidden');
            clearRosterBtn.classList.add('hidden');

            // Initial check for holiday indicators if dates are pre-filled
            updateDateInputHolidayIndicator(startDateInput, startDateHolidayIndicator);
            updateDateInputHolidayIndicator(endDateInput, endDateHolidayIndicator);
        });
    </script>
</body>
</html>
