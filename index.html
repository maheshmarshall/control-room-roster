<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Room Roster Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general layout */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Dark slate gray text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            background-color: #ffffff; /* White container background */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 30px;
            width: 100%;
            max-width: 1200px; /* Max width for larger screens */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #1e293b; /* Darker title */
            text-align: center;
            margin-bottom: 20px;
            font-weight: 700; /* Bold font */
        }
        .input-group label {
            font-weight: 600; /* Semi-bold label */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input[type="date"],
        .input-group textarea,
        .input-group select,
        .input-group input[type="text"] { /* Added text input for styling */
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 8px; /* Slightly rounded inputs */
            background-color: #f8fafc; /* Lighter input background */
            transition: all 0.2s ease-in-out;
        }
        .input-group input[type="date"]:focus,
        .input-group textarea:focus,
        .input-group select:focus,
        .input-group input[type="text"]:focus { /* Added text input for styling */
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Soft focus shadow */
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: #4f46e5; /* Indigo button */
            color: white;
            border: none;
        }
        .btn:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-1px); /* Slight lift effect */
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray button */
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        .roster-output {
            overflow-x: auto; /* Enable horizontal scrolling for the table */
            margin-top: 20px;
            border: 1px solid #e2e8f0; /* Light border around roster */
            border-radius: 8px;
        }
        .roster-table {
            width: 100%;
            border-collapse: collapse; /* Collapse table borders */
            min-width: 800px; /* Ensure minimum width for scrolling */
            margin-bottom: 20px; /* Space between multiple tables */
        }
        .roster-table th,
        .roster-table td {
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e2e8f0; /* Cell borders */
            white-space: nowrap; /* Prevent date/shift wrapping */
        }
        .roster-table thead th {
            background-color: #e0e7ff; /* Light indigo header */
            font-weight: 700;
            color: #374151;
            position: sticky; /* Sticky header for scrolling */
            top: 0;
            z-index: 10;
        }
        .roster-table tbody tr:nth-child(even) {
            background-color: #f8fafc; /* Zebra striping */
        }
        .roster-table tbody tr:hover {
            background-color: #eff6ff; /* Highlight row on hover */
        }
        .roster-table td:first-child {
            text-align: left; /* Align employee names to left */
            font-weight: 500;
            background-color: #e0e7ff; /* Light indigo for employee column */
            position: sticky; /* Sticky first column */
            left: 0;
            z-index: 10;
        }
        /* Adjust sticky header background for the first column */
        .roster-table th:first-child {
            background-color: #c7d2fe; /* Darker indigo for sticky corner */
            z-index: 11; /* Ensure it's above other sticky elements */
        }
        
        /* Message box styling */
        .message-box {
            background-color: #fff3cd; /* Light yellow background */
            border: 1px solid #ffeeba; /* Yellow border */
            color: #664d03; /* Dark yellow text */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            display: none; /* Hidden by default */
        }
        .message-box.show {
            display: block;
        }

        /* Sunday Highlight Styles */
        .sunday-column-header {
            background-color: #fecaca; /* Lighter red for header */
            color: #dc2626; /* Red text */
            font-weight: 700;
        }
        .sunday-column-cell {
            background-color: #fee2e2; /* Lightest red for data cells */
            color: #b91c1c; /* Darker red text */
        }

        /* Public Holiday Highlight Styles */
        .public-holiday-column-header {
            background-color: #fef3c7; /* Light orange/yellow for header */
            color: #d97706; /* Darker orange/yellow text */
            font-weight: 700;
        }
        .public-holiday-column-cell {
            background-color: #fefce8; /* Lightest orange/yellow for data cells */
            color: #b45309; /* Darker orange/yellow text */
        }

        /* Roster Summary Styles */
        .roster-summary {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0f9ff; /* Light blue background */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .roster-summary h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 15px;
            text-align: center;
        }
        .summary-table-container { /* New class for scrollability */
            overflow-x: auto;
            border-radius: 12px; /* Inherit border-radius from parent */
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px; /* Ensure minimum width for scrolling */
        }
        .summary-table th,
        .summary-table td {
            padding: 10px 15px;
            border: 1px solid #e2e8f0;
            text-align: left;
        }
        .summary-table thead th {
            background-color: #dbeafe; /* Lighter blue header */
            font-weight: 600;
            color: #1e40af;
        }
        .summary-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .summary-table tbody tr:hover {
            background-color: #e0f2fe;
        }
        /* Center calculation columns */
        .summary-table td:last-child,
        .summary-table td:nth-last-child(2),
        .summary-table td:nth-last-child(3),
        .summary-table td:nth-last-child(4),
        .summary-table td:nth-last-child(5), /* New: Extra Pay columns */
        .summary-table td:nth-last-child(6),
        .summary-table td:nth-last-child(7),
        .summary-table td:nth-last-child(8),
        .summary-table td:nth-last-child(9),
        .summary-table td:nth-last-child(10), /* Added for 'normal time' */
        .summary-table td:nth-last-child(11) { /* Added for 'Day&Night' */
            text-align: center;
            font-weight: 500;
        }

        /* Leave Type Styling */
        .leave-cell {
            font-weight: 600;
            color: white; /* Default text color for leave */
        }
        .leave-annual-leave { /* Corrected class name */
            background-color: #34d399; /* Green for Annual Leave ( Tailwind green-500) */
        }
        .leave-sick-leave { /* Corrected class name */
            background-color: #facc15; /* Yellow for Sick Leave (Tailwind yellow-400) */
            color: #334155; /* Dark text for readability on yellow */
        }
        .leave-family-responsibility { /* Corrected class name */
            background-color: #f97316; /* Orange for Family Responsibility (Tailwind orange-500) */
        }
        .leave-unpaid-leave { /* Corrected class name */
            background-color: #ef4444; /* Red for Unpaid Leave (Tailwind red-500) */
        }
        .leave-info {
            background-color: #60a5fa; /* Blue for general info/tooltip */
        }

        /* Extra Pay Styling */
        .extra-pay-cell {
            font-weight: 600;
            color: white;
            background-color: #a78bfa; /* Purple for general extra pay (Tailwind purple-400) */
        }
        .extra-pay-day-overtime {
            background-color: #818cf8; /* Light Blue/Indigo for Day OT (Tailwind indigo-400) */
        }
        .extra-pay-night-overtime {
            background-color: #4c1d95; /* Darker Purple for Night OT (Tailwind violet-800) */
        }
        .extra-pay-public-holiday-day-shift {
            background-color: #22c55e; /* Bright Green for PH Day (Tailwind green-500) */
        }
        .extra-pay-public-holiday-night-shift {
            background-color: #16a34a; /* Dark Green for PH Night (Tailwind green-700) */
        }
        .extra-pay-one-normal-time-and-one-o-t-2 {
            background-color: #ec4899; /* Pink for OT2 (Tailwind pink-500) */
        }
        /* New extra pay types */
        .extra-pay-day-night { /* Combined Day&Night */
            background-color: #a855f7; /* Violet for Day&Night (Tailwind violet-500) */
        }

        /* Dynamic row styling */
        .dynamic-input-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto; /* 3 columns for inputs, 1 for button */
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: end; /* Align items to the bottom */
        }
        .dynamic-input-row .input-group {
            margin-bottom: 0; /* Remove default margin from input-group */
        }
        .dynamic-input-row .remove-btn {
            padding: 10px 12px;
            background-color: #ef4444; /* Red */
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            height: 42px; /* Match input height */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dynamic-input-row .remove-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
    </style>
</head>
<body class="selection:bg-indigo-300">
    <div class="container">
        <h1 class="text-3xl sm:text-4xl">Control Room Roster Generator</h1>

        <div class="input-section grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="input-group">
                <label for="startDate">Roster Start Date:</label>
                <input type="date" id="startDate" class="form-input" min="" max="">
            </div>
            <div class="input-group">
                <label for="endDate">Roster End Date:</label>
                <input type="date" id="endDate" class="form-input" min="" max="">
            </div>
        </div>

        <div class="input-section grid grid-cols-1 md:grid-cols-3 gap-6 mt-6"> <!-- New section for shifts -->
            <div class="input-group">
                <label for="employeesA">Shift A Employees (One per line):</label>
                <textarea id="employeesA" rows="8" placeholder="Enter Shift A employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesB">Shift B Employees (One per line):</label>
                <textarea id="employeesB" rows="8" placeholder="Enter Shift B employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesC">Shift C Employees (One per line):</label>
                <textarea id="employeesC" rows="8" placeholder="Enter Shift C employee names here..." class="form-textarea"></textarea>
            </div>
        </div>

        <!-- Shift Pattern Input Section -->
        <div class="input-section grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
            <div class="input-group">
                <label for="patternA">Shift A Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternA" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
            <div class="input-group">
                <label for="patternB">Shift B Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternB" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
            <div class="input-group">
                <label for="patternC">Shift C Pattern (e.g., DDDNNNOOO):</label>
                <input type="text" id="patternC" class="form-input" value="DDDNNNOOO" pattern="[DNO]+" title="Pattern must contain only D, N, or O characters">
            </div>
        </div>

        <div class="button-group">
            <button id="generateRosterBtn" class="btn">Generate Roster</button>
            <button id="exportCsvBtn" class="btn">Export to CSV</button>
            <button id="generateShiftInsightsBtn" class="btn">Generate Shift Insights ✨</button> <!-- New LLM Button -->
            <button id="clearRosterBtn" class="btn btn-secondary">Clear Roster</button>
        </div>

        <div id="messageBox" class="message-box"></div>

        <!-- Leave Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Leave Management</h2>
            <div id="leaveInputsContainer">
                <!-- Dynamic leave input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addLeaveEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Leave Entry</button>
                <button id="applyAllLeaveBtn" class="btn bg-blue-500 hover:bg-blue-700 text-white">Apply All Leave</button>
            </div>
            <div id="leaveCountOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Leave Counts:</h3>
                <ul id="leaveCountsList" class="list-disc pl-5"></ul>
            </div>
        </div>

        <!-- Extra Pay Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Extra Pay Management</h2>
            <div id="extraPayInputsContainer">
                <!-- Dynamic extra pay input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addExtraPayEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Extra Pay Entry</button>
                <button id="applyAllExtraPayBtn" class="btn bg-purple-500 hover:bg-purple-700 text-white">Apply All Extra Pay</button>
            </div>
            <div id="extraPayOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Extra Pay Details:</h3>
                <ul id="extraPayList" class="list-disc pl-5"></ul>
            </div>
        </div>


        <div id="rosterOutput" class="roster-output hidden">
            <!-- Roster table(s) will be generated here -->
        </div>

        <div id="rosterSummary" class="roster-summary hidden">
            <h2>Roster Summary</h2>
            <div id="summaryTableContainer" class="summary-table-container">
                <!-- Summary table will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variable to store shift descriptions from LLM
        let shiftDescriptions = null;

        // Global variables to store leave data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Leave Type" } }
        let employeeLeaveData = {};
        // Example: { "Employee Name": { "annual leave": 5, "sick leave": 2 } }
        let employeeLeaveCounts = {};

        // Global variable to store extra pay data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Extra Pay Type" } }
        let employeeExtraPayData = {};

        // Define all possible extra pay types for summary table columns
        const ALL_EXTRA_PAY_TYPES = [
            'day overtime',
            'night overtime',
            'public holiday day shift',
            'public holiday night shift',
            'one normal time and one o/t 2',
            'Day&Night' // Modified extra pay type
        ];

        // Define all possible leave types
        const ALL_LEAVE_TYPES = [
            'annual leave',
            'sick leave',
            'family responsibility',
            'unpaid leave'
        ];

        // South African Public Holidays (YYYY-MM-DD format) - Observed dates
        const SOUTH_AFRICAN_PUBLIC_HOLIDAYS = new Set([
            // 2025
            '2025-01-01', // New Year's Day
            '2025-03-21', // Human Rights Day
            '2025-04-18', // Good Friday
            '2025-04-21', // Family Day
            '2025-04-28', // Freedom Day (Observed, since 27th is Sunday)
            '2025-05-01', // Workers' Day
            '2025-06-16', // Youth Day
            '2025-08-11', // National Women's Day (Observed, since 9th is Saturday)
            '2025-09-24', // Heritage Day
            '2025-12-16', // Day of Reconciliation
            '2025-12-25', // Christmas Day
            '2025-12-26', // Day of Goodwill
            // 2026
            '2026-01-01', // New Year's Day
            '2026-03-23', // Human Rights Day (Observed, since 21st is Saturday)
            '2026-04-03', // Good Friday
            '2026-04-06', // Family Day
            '2026-04-27', // Freedom Day
            '2026-05-01', // Workers' Day
            '2026-06-16', // Youth Day
            '2026-08-10', // National Women's Day (Observed, since 9th is Sunday)
            '2026-09-24', // Heritage Day
            '2026-12-16', // Day of Reconciliation
            '2026-12-25', // Christmas Day
            '2026-12-26'  // Day of Goodwill
        ]);

        /**
         * Checks if a given date string is a South African public holiday.
         * @param {string} dateString - The date string in YYYY-MM-DD format.
         * @returns {boolean} True if it's a public holiday, false otherwise.
         */
        function isPublicHoliday(dateString) {
            return SOUTH_AFRICAN_PUBLIC_HOLIDAYS.has(dateString);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const employeesATextarea = document.getElementById('employeesA');
            const employeesBTextarea = document.getElementById('employeesB');
            const employeesCTextarea = document.getElementById('employeesC');
            // New shift pattern inputs
            const patternAInput = document.getElementById('patternA');
            const patternBInput = document.getElementById('patternB');
            const patternCInput = document.getElementById('patternC');

            const generateRosterBtn = document.getElementById('generateRosterBtn');
            const exportCsvBtn = document.getElementById('exportCsvBtn');
            const generateShiftInsightsBtn = document.getElementById('generateShiftInsightsBtn'); // New: LLM Button
            const clearRosterBtn = document.getElementById('clearRosterBtn');
            const rosterOutputDiv = document.getElementById('rosterOutput');
            const messageBox = document.getElementById('messageBox');
            const rosterSummaryDiv = document.getElementById('rosterSummary');
            const summaryTableContainer = document.getElementById('summaryTableContainer');

            // Leave Management DOM elements
            const leaveInputsContainer = document.getElementById('leaveInputsContainer');
            const addLeaveEntryBtn = document.getElementById('addLeaveEntryBtn');
            const applyAllLeaveBtn = document.getElementById('applyAllLeaveBtn');
            const leaveCountOutput = document.getElementById('leaveCountOutput');
            const leaveCountsList = document.getElementById('leaveCountsList');

            // Extra Pay Management DOM elements
            const extraPayInputsContainer = document.getElementById('extraPayInputsContainer');
            const addExtraPayEntryBtn = document.getElementById('addExtraPayEntryBtn');
            const applyAllExtraPayBtn = document.getElementById('applyAllExtraPayBtn');
            const extraPayOutput = document.getElementById('extraPayOutput');
            const extraPayList = document.getElementById('extraPayList');


            // Set min date to 2025-01-01
            const overallMinDate = `2025-01-01`;
            // Max date is December 31st of the next year from the current year
            const currentYear = new Date().getFullYear();
            const nextYear = currentYear + 1;
            const overallMaxDate = `${nextYear}-12-31`;

            startDateInput.setAttribute('min', overallMinDate);
            startDateInput.setAttribute('max', overallMaxDate);
            endDateInput.setAttribute('min', overallMinDate);
            endDateInput.setAttribute('max', overallMaxDate);

            // Set employee textareas to be blank by default
            employeesATextarea.value = '';
            employeesBTextarea.value = '';
            employeesCTextarea.value = '';

            /**
             * Helper function to parse a YYYY-MM-DD string into a Date object in local time.
             * @param {string} dateString - The date string in YYYY-MM-DD format.
             * @returns {Date} A Date object representing the date in local time.
             */
            function parseDateString(dateString) {
                const [year, month, day] = dateString.split('-').map(Number);
                // Month is 0-indexed in JavaScript Date constructor
                return new Date(year, month - 1, day);
            }

            /**
             * Helper function to format a Date object into a YYYY-MM-DD string in local time.
             * @param {Date} date - The Date object to format.
             * @returns {string} The date string in YYYY-MM-DD format.
             */
            function formatDateToYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
                const day = date.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Event listener to ensure endDate is not before startDate
            startDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        // Adjust endDate to be a reasonable date after startDate, e.g., 15th of next month
                        const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                        endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                        showMessage('End date adjusted to be after start date.', 'info');
                    }
                } else if (startDateInput.value && !endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                    endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                }
                endDateInput.setAttribute('min', startDateInput.value);
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
            });

            endDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        showMessage('End date cannot be before start date. Please correct.', 'error');
                        endDateInput.value = '';
                    }
                }
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
            });

            /**
             * Updates the min/max attributes for date inputs in dynamic rows.
             */
            function updateDynamicRowDateConstraints() {
                const minDate = startDateInput.value;
                const maxDate = endDateInput.value;

                document.querySelectorAll('.dynamic-input-row input[type="date"]').forEach(input => {
                    input.setAttribute('min', minDate);
                    input.setAttribute('max', maxDate);
                });
            }


            /**
             * Displays a message in the message box.
             * @param {string} message - The message to display.
             * @param {string} type - The type of message (e.g., 'error', 'info', 'success', 'warning').
             */
            function showMessage(message, type = 'info') {
                messageBox.textContent = message;
                messageBox.className = 'message-box show';
                // Clear previous type classes
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                
                if (type === 'error') {
                    messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
                } else if (type === 'success') {
                    messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
                } else if (type === 'warning') {
                    messageBox.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                } else {
                    messageBox.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
                }
                setTimeout(() => {
                    hideMessage();
                }, 5000);
            }

            /**
             * Hides the message box.
             */
            function hideMessage() {
                messageBox.className = 'message-box';
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
            }


            /**
             * Determines the shift type (D, N, O) based on the day's index within the cycle and the provided pattern.
             * @param {number} dayIndexInCycle - The 0-indexed day within the cycle.
             * @param {string} pattern - The shift pattern (e.g., "DDDNNNOOO").
             * @returns {string} The shift type ('D', 'N', or 'O').
             */
            function getShiftType(dayIndexInCycle, pattern) {
                // Ensure pattern is valid and has expected length
                const patternLength = pattern.length;
                if (!pattern || patternLength === 0 || !/^[DNO]+$/.test(pattern)) {
                    // Fallback to a default 9-day pattern if invalid
                    return ["D", "D", "D", "N", "N", "N", "O", "O", "O"][dayIndexInCycle % 9];
                }
                return pattern[dayIndexInCycle % patternLength];
            }

            /**
             * Applies LLM-generated shift descriptions as tooltips to the roster cells.
             */
            function applyShiftDescriptions() {
                if (!shiftDescriptions) {
                    return; // No descriptions to apply
                }
                const shiftCells = rosterOutputDiv.querySelectorAll('.roster-table tbody td');
                shiftCells.forEach(cell => {
                    // Only apply tooltip if it's a shift, not a leave or extra pay
                    if (!cell.classList.contains('leave-cell') && !cell.classList.contains('extra-pay-cell')) {
                        const shiftType = cell.textContent.trim();
                        if (shiftDescriptions[shiftType]) {
                            cell.setAttribute('title', shiftDescriptions[shiftType]);
                        }
                    }
                });
            }

            /**
             * Generates a single roster table for a given set of employees.
             * @param {Array<string>} employees - List of employee names for this shift.
             * @param {Array<Date>} dates - List of dates in the roster period.
             * @param {Object} currentEmployeeShiftCounts - Object to accumulate shift counts for all employees.
             * @param {string} shiftName - The name of the shift (e.g., "Shift A").
             * @param {string} shiftPattern - The pattern for this shift.
             * @returns {string} The HTML string for the generated roster table.
             */
            function generateSingleRosterTable(employees, dates, currentEmployeeShiftCounts, shiftName, shiftPattern) {
                // Array for short day names (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
                const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

                let tableHTML = `<h3 class="text-xl font-semibold mb-2 mt-4 text-center">${shiftName} Roster</h3>`;
                tableHTML += `<table class="roster-table"><thead>`;
                
                // First header row for "Employee Name" and Dates
                tableHTML += `<tr><th class="employee-header" rowspan="2">Employee Name</th>`; // rowspan for employee header
                dates.forEach(date => {
                    // Check if the current date is a Sunday or Public Holiday
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const isPH = isPublicHoliday(dateString);

                    let headerHighlightClass = '';
                    if (isSunday) {
                        headerHighlightClass += ' sunday-column-header';
                    }
                    if (isPH) {
                        headerHighlightClass += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${headerHighlightClass.trim()}">${date.getDate()}/${(date.getMonth() + 1).toString().padStart(2, '0')}</th>`;
                });
                tableHTML += `</tr>`;

                // Second header row for Day of the Week
                tableHTML += `<tr>`;
                dates.forEach(date => {
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const isPH = isPublicHoliday(dateString);

                    let highlightClass = '';
                    if (isSunday) {
                        highlightClass += ' sunday-column-header';
                    }
                    if (isPH) {
                        highlightClass += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${highlightClass.trim()}">${dayNames[date.getDay()]}</th>`;
                });
                tableHTML += `</tr></thead><tbody>`;

                // Add rows for each employee in this shift
                employees.forEach((employeeName) => {
                    // Ensure employee entry exists in currentEmployeeShiftCounts
                    if (!currentEmployeeShiftCounts[employeeName]) {
                        currentEmployeeShiftCounts[employeeName] = { 
                            D: 0, N: 0, O: 0, normalHours: 0,
                            totalSundays: 0, sundayHoursTimeAndAHalf: 0,
                            // Initialize all leave types
                            'annual leave': 0, 'sick leave': 0, 'family responsibility': 0, 'unpaid leave': 0,
                            // Initialize all extra pay types
                            ...Object.fromEntries(ALL_EXTRA_PAY_TYPES.map(type => [type, 0]))
                        };
                    }

                    tableHTML += `<tr><td>${employeeName}</td>`;
                    dates.forEach((date, dayIndex) => {
                        const dateString = formatDateToYYYYMMDD(date);
                        const isSunday = date.getDay() === 0;
                        const isPH = isPublicHoliday(dateString);

                        let cellContent = '';
                        let cellClass = '';
                        let isShiftAssigned = true; // Flag to check if a regular shift is assigned or overridden

                        // Check for Leave
                        if (employeeLeaveData[employeeName] && employeeLeaveData[employeeName][dateString]) {
                            const leaveType = employeeLeaveData[employeeName][dateString];
                            cellContent = leaveType.toUpperCase().split(' ').map(word => word[0]).join(''); // Abbreviate leave type
                            cellClass = `leave-cell leave-${leaveType.toLowerCase().replace(/ /g, '-')}`;
                            currentEmployeeShiftCounts[employeeName][leaveType]++;
                            isShiftAssigned = false;
                        } 
                        // Check for Extra Pay (Extra pay overrides normal shift display if present)
                        else if (employeeExtraPayData[employeeName] && employeeExtraPayData[employeeName][dateString]) {
                            const extraPayType = employeeExtraPayData[employeeName][dateString];
                            cellContent = extraPayType.toUpperCase().split(' ').map(word => word[0]).join(''); // Abbreviate extra pay type
                            cellClass = `extra-pay-cell extra-pay-${extraPayType.toLowerCase().replace(/ /g, '-')}`;
                            currentEmployeeShiftCounts[employeeName][extraPayType]++; // Increment count for this extra pay type
                            isShiftAssigned = false;
                        }
                        
                        // If no leave or extra pay, assign regular shift
                        if (isShiftAssigned) {
                            // The shift cycle for each employee within a shift group can be offset.
                            // The `employees.indexOf(employeeName)` provides a unique index for each employee within THIS specific shift (A, B, or C).
                            // Multiplying by the pattern length ensures a staggered start for each employee's pattern if there are multiple employees in one shift.
                            const dayIndexInCycle = (dayIndex + employees.indexOf(employeeName) * shiftPattern.length) % shiftPattern.length;
                            const shiftType = getShiftType(dayIndexInCycle, shiftPattern);
                            cellContent = shiftType;
                            
                            currentEmployeeShiftCounts[employeeName][shiftType]++;
                            if (shiftType === 'D' || shiftType === 'N') {
                                currentEmployeeShiftCounts[employeeName].normalHours += 8; // Assuming 8-hour shifts
                                if (isSunday) {
                                    currentEmployeeShiftCounts[employeeName].totalSundays++;
                                    currentEmployeeShiftCounts[employeeName].sundayHoursTimeAndAHalf += 8; // 8 hours at time and a half
                                }
                            }
                            // Apply Sunday/Public Holiday highlighting to the shift cell
                            if (isSunday) {
                                cellClass += ' sunday-column-cell';
                            }
                            if (isPH) {
                                cellClass += ' public-holiday-column-cell';
                            }
                        } else {
                            // If leave or extra pay, still apply Sunday/Public Holiday background if applicable
                            if (isSunday) {
                                cellClass += ' sunday-column-cell';
                            }
                            if (isPH) {
                                cellClass += ' public-holiday-column-cell';
                            }
                        }
                        tableHTML += `<td class="${cellClass.trim()}">${cellContent}</td>`;
                    });
                    tableHTML += `</tr>`;
                });
                tableHTML += `</tbody></table>`;
                return tableHTML;
            }

            /**
             * Generates the main roster by combining all shift tables.
             */
            function generateRoster() {
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const employeesA = employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e);
                const employeesB = employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e);
                const employeesC = employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e);

                // Get shift patterns
                const patternA = patternAInput.value.toUpperCase();
                const patternB = patternBInput.value.toUpperCase();
                const patternC = patternCInput.value.toUpperCase();

                // Validate shift patterns - removed length validation
                const patternRegex = /^[DNO]+$/; // Allows any length, but only D, N, O characters
                if (!patternRegex.test(patternA)) {
                    showMessage('Shift A pattern must contain only D, N, or O characters.', 'error');
                    return;
                }
                if (!patternRegex.test(patternB)) {
                    showMessage('Shift B pattern must contain only D, N, or O characters.', 'error');
                    return;
                }
                if (!patternRegex.test(patternC)) {
                    showMessage('Shift C pattern must contain only D, N, or O characters.', 'error');
                    return;
                }


                if (!startDate || !endDate) {
                    showMessage('Please select both start and end dates.', 'error');
                    return;
                }
                if (employeesA.length === 0 && employeesB.length === 0 && employeesC.length === 0) {
                    showMessage('Please enter at least one employee for any shift.', 'error');
                    return;
                }

                const start = parseDateString(startDate);
                const end = parseDateString(endDate);
                if (start > end) {
                    showMessage('Start date cannot be after end date.', 'error');
                    return;
                }

                const dates = [];
                let currentDate = new Date(start);
                while (currentDate <= end) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                rosterOutputDiv.innerHTML = '';
                rosterSummaryDiv.innerHTML = ''; // Clear previous summary

                // Reset employee shift counts for new generation
                let currentEmployeeShiftCounts = {};

                if (employeesA.length > 0) {
                    rosterOutputDiv.innerHTML += generateSingleRosterTable(employeesA, dates, currentEmployeeShiftCounts, "Shift A", patternA);
                }
                if (employeesB.length > 0) {
                    rosterOutputDiv.innerHTML += generateSingleRosterTable(employeesB, dates, currentEmployeeShiftCounts, "Shift B", patternB);
                }
                if (employeesC.length > 0) {
                    rosterOutputDiv.innerHTML += generateSingleRosterTable(employeesC, dates, currentEmployeeShiftCounts, "Shift C", patternC);
                }

                rosterOutputDiv.classList.remove('hidden');
                
                // Generate and display the summary
                generateRosterSummary(currentEmployeeShiftCounts, dates.length);

                // Apply LLM descriptions if available
                applyShiftDescriptions();
                showMessage('Roster generated successfully!', 'success');
            }

            /**
             * Generates and displays the roster summary table.
             * @param {Object} employeeShiftData - Accumulated shift, leave, and extra pay counts for each employee.
             * @param {number} totalDaysInRoster - Total number of days in the roster period.
             */
            function generateRosterSummary(employeeShiftData, totalDaysInRoster) {
                let summaryHTML = `<h2>Roster Summary</h2>`;
                summaryHTML += `<div class="summary-table-container"><table class="summary-table"><thead><tr>`;
                summaryHTML += `<th>Employee Name</th>`;
                summaryHTML += `<th>Day Shifts (D)</th>`;
                summaryHTML += `<th>Night Shifts (N)</th>`;
                summaryHTML += `<th>Off Days (O)</th>`;
                summaryHTML += `<th>Normal Hours</th>`;
                summaryHTML += `<th>Sundays Worked</th>`;
                summaryHTML += `<th>Sunday Hours (x1.5)</th>`;
                
                // Add Leave Type headers
                ALL_LEAVE_TYPES.forEach(leaveType => {
                    summaryHTML += `<th>${leaveType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')} Days</th>`;
                });

                // Add Extra Pay Type headers
                ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                    summaryHTML += `<th>${extraPayType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}</th>`;
                });

                summaryHTML += `</tr></thead><tbody>`;

                for (const employeeName in employeeShiftData) {
                    const data = employeeShiftData[employeeName];
                    summaryHTML += `<tr>`;
                    summaryHTML += `<td>${employeeName}</td>`;
                    summaryHTML += `<td>${data.D || 0}</td>`;
                    summaryHTML += `<td>${data.N || 0}</td>`;
                    summaryHTML += `<td>${data.O || 0}</td>`;
                    summaryHTML += `<td>${data.normalHours || 0}</td>`;
                    summaryHTML += `<td>${data.totalSundays || 0}</td>`;
                    summaryHTML += `<td>${data.sundayHoursTimeAndAHalf || 0}</td>`;

                    // Add Leave Type counts
                    ALL_LEAVE_TYPES.forEach(leaveType => {
                        summaryHTML += `<td>${data[leaveType] || 0}</td>`;
                    });

                    // Add Extra Pay Type counts
                    ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                        summaryHTML += `<td>${data[extraPayType] || 0}</td>`;
                    });

                    summaryHTML += `</tr>`;
                }

                summaryHTML += `</tbody></table></div>`;
                rosterSummaryDiv.innerHTML = summaryHTML;
                rosterSummaryDiv.classList.remove('hidden');
            }

            /**
             * Adds a new dynamic input row for leave entry.
             */
            function addLeaveEntry() {
                const leaveEntryDiv = document.createElement('div');
                leaveEntryDiv.classList.add('dynamic-input-row');

                const allEmployees = [
                    ...employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e)
                ];
                const uniqueEmployees = [...new Set(allEmployees)]; // Get unique names

                if (uniqueEmployees.length === 0) {
                    showMessage('Please enter employees in the shift text areas first to add leave entries.', 'warning');
                    return;
                }

                leaveEntryDiv.innerHTML = `
                    <div class="input-group">
                        <label for="leaveEmployee">Employee:</label>
                        <select class="form-select leave-employee">
                            <option value="">Select Employee</option>
                            ${uniqueEmployees.map(emp => `<option value="${emp}">${emp}</option>`).join('')}
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="leaveStartDate">Start Date:</label>
                        <input type="date" class="form-input leave-start-date" min="${startDateInput.value}" max="${endDateInput.value}">
                    </div>
                    <div class="input-group">
                        <label for="leaveEndDate">End Date:</label>
                        <input type="date" class="form-input leave-end-date" min="${startDateInput.value}" max="${endDateInput.value}">
                    </div>
                    <div class="input-group">
                        <label for="leaveType">Leave Type:</label>
                        <select class="form-select leave-type">
                            <option value="">Select Type</option>
                            <option value="annual leave">Annual Leave</option>
                            <option value="sick leave">Sick Leave</option>
                            <option value="family responsibility">Family Responsibility</option>
                            <option value="unpaid leave">Unpaid Leave</option>
                        </select>
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;
                leaveInputsContainer.appendChild(leaveEntryDiv);

                // Add event listener for remove button
                leaveEntryDiv.querySelector('.remove-btn').addEventListener('click', () => {
                    leaveEntryDiv.remove();
                });

                // Add event listeners for date validation within the dynamically added row
                const leaveStartDateInput = leaveEntryDiv.querySelector('.leave-start-date');
                const leaveEndDateInput = leaveEntryDiv.querySelector('.leave-end-date');

                leaveStartDateInput.addEventListener('change', () => {
                    if (leaveStartDateInput.value && leaveEndDateInput.value) {
                        const start = parseDateString(leaveStartDateInput.value);
                        const end = parseDateString(leaveEndDateInput.value);
                        if (start > end) {
                            leaveEndDateInput.value = '';
                            showMessage('Leave end date cannot be before start date.', 'warning');
                        }
                    }
                    leaveEndDateInput.setAttribute('min', leaveStartDateInput.value);
                });

                leaveEndDateInput.addEventListener('change', () => {
                    if (leaveStartDateInput.value && leaveEndDateInput.value) {
                        const start = parseDateString(leaveStartDateInput.value);
                        const end = parseDateString(leaveEndDateInput.value);
                        if (start > end) {
                            leaveEndDateInput.value = '';
                            showMessage('Leave end date cannot be before start date.', 'warning');
                        }
                    }
                });
                updateDynamicRowDateConstraints(); // Apply global date constraints
            }

            /**
             * Applies all entered leave data to the employeeLeaveData and employeeLeaveCounts.
             * Then regenerates the roster.
             */
            function applyAllLeave() {
                employeeLeaveData = {}; // Clear previous leave data
                employeeLeaveCounts = {}; // Clear previous leave counts
                let isValid = true;

                document.querySelectorAll('#leaveInputsContainer .dynamic-input-row').forEach(row => {
                    const employeeSelect = row.querySelector('.leave-employee');
                    const startDateInput = row.querySelector('.leave-start-date');
                    const endDateInput = row.querySelector('.leave-end-date');
                    const leaveTypeSelect = row.querySelector('.leave-type');

                    const employeeName = employeeSelect.value;
                    const startDate = startDateInput.value;
                    const endDate = endDateInput.value;
                    const leaveType = leaveTypeSelect.value;

                    if (!employeeName || !startDate || !endDate || !leaveType) {
                        showMessage('Please fill all fields for each leave entry.', 'error');
                        isValid = false;
                        return;
                    }

                    const start = parseDateString(startDate);
                    const end = parseDateString(endDate);

                    if (start > end) {
                        showMessage(`Leave end date for ${employeeName} cannot be before start date.`, 'error');
                        isValid = false;
                        return;
                    }

                    if (!employeeLeaveData[employeeName]) {
                        employeeLeaveData[employeeName] = {};
                    }
                    if (!employeeLeaveCounts[employeeName]) {
                        employeeLeaveCounts[employeeName] = Object.fromEntries(ALL_LEAVE_TYPES.map(type => [type, 0]));
                    }

                    let currentDate = new Date(start);
                    while (currentDate <= end) {
                        const dateString = formatDateToYYYYMMDD(currentDate);
                        employeeLeaveData[employeeName][dateString] = leaveType;
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                });

                if (isValid) {
                    generateRoster(); // Regenerate roster with applied leave
                    displayLeaveCounts(); // Display updated leave counts
                    showMessage('Leave applied successfully!', 'success');
                }
            }

            /**
             * Displays the accumulated leave counts for each employee.
             */
            function displayLeaveCounts() {
                leaveCountsList.innerHTML = '';
                let hasLeave = false;
                for (const employeeName in employeeLeaveData) {
                    const leaveDates = employeeLeaveData[employeeName];
                    const counts = {};
                    for (const date in leaveDates) {
                        const type = leaveDates[date];
                        counts[type] = (counts[type] || 0) + 1;
                    }

                    let employeeLeaveSummary = `${employeeName}: `;
                    const leaveTypesPresent = Object.keys(counts).filter(type => counts[type] > 0);

                    if (leaveTypesPresent.length > 0) {
                        hasLeave = true;
                        employeeLeaveSummary += leaveTypesPresent.map(type => `${type.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}: ${counts[type]}`).join(', ');
                        const listItem = document.createElement('li');
                        listItem.textContent = employeeLeaveSummary;
                        leaveCountsList.appendChild(listItem);
                    }
                }
                if (hasLeave) {
                    leaveCountOutput.classList.remove('hidden');
                } else {
                    leaveCountOutput.classList.add('hidden');
                }
            }

            /**
             * Adds a new dynamic input row for extra pay entry.
             */
            function addExtraPayEntry() {
                const extraPayEntryDiv = document.createElement('div');
                extraPayEntryDiv.classList.add('dynamic-input-row');

                const allEmployees = [
                    ...employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e)
                ];
                const uniqueEmployees = [...new Set(allEmployees)];

                if (uniqueEmployees.length === 0) {
                    showMessage('Please enter employees in the shift text areas first to add extra pay entries.', 'warning');
                    return;
                }

                extraPayEntryDiv.innerHTML = `
                    <div class="input-group">
                        <label for="extraPayEmployee">Employee:</label>
                        <select class="form-select extra-pay-employee">
                            <option value="">Select Employee</option>
                            ${uniqueEmployees.map(emp => `<option value="${emp}">${emp}</option>`).join('')}
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="extraPayDate">Date:</label>
                        <input type="date" class="form-input extra-pay-date" min="${startDateInput.value}" max="${endDateInput.value}">
                    </div>
                    <div class="input-group">
                        <label for="extraPayType">Extra Pay Type:</label>
                        <select class="form-select extra-pay-type">
                            <option value="">Select Type</option>
                            <option value="day overtime">Day Overtime</option>
                            <option value="night overtime">Night Overtime</option>
                            <option value="public holiday day shift">Public Holiday Day Shift</option>
                            <option value="public holiday night shift">Public Holiday Night Shift</option>
                            <option value="one normal time and one o/t 2">One Normal Time & One O/T 2</option>
                            <option value="Day&Night">Day & Night</option>
                        </select>
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;
                extraPayInputsContainer.appendChild(extraPayEntryDiv);

                // Add event listener for remove button
                extraPayEntryDiv.querySelector('.remove-btn').addEventListener('click', () => {
                    extraPayEntryDiv.remove();
                });
                updateDynamicRowDateConstraints(); // Apply global date constraints
            }

            /**
             * Applies all entered extra pay data to the employeeExtraPayData.
             * Then regenerates the roster.
             */
            function applyAllExtraPay() {
                employeeExtraPayData = {}; // Clear previous extra pay data
                let isValid = true;

                document.querySelectorAll('#extraPayInputsContainer .dynamic-input-row').forEach(row => {
                    const employeeSelect = row.querySelector('.extra-pay-employee');
                    const dateInput = row.querySelector('.extra-pay-date');
                    const extraPayTypeSelect = row.querySelector('.extra-pay-type');

                    const employeeName = employeeSelect.value;
                    const date = dateInput.value;
                    const extraPayType = extraPayTypeSelect.value;

                    if (!employeeName || !date || !extraPayType) {
                        showMessage('Please fill all fields for each extra pay entry.', 'error');
                        isValid = false;
                        return;
                    }

                    if (!employeeExtraPayData[employeeName]) {
                        employeeExtraPayData[employeeName] = {};
                    }
                    employeeExtraPayData[employeeName][date] = extraPayType;
                });

                if (isValid) {
                    generateRoster(); // Regenerate roster with applied extra pay
                    displayExtraPayDetails(); // Display updated extra pay details
                    showMessage('Extra pay applied successfully!', 'success');
                }
            }

            /**
             * Displays the accumulated extra pay details for each employee.
             */
            function displayExtraPayDetails() {
                extraPayList.innerHTML = '';
                let hasExtraPay = false;
                for (const employeeName in employeeExtraPayData) {
                    const extraPayDates = employeeExtraPayData[employeeName];
                    const details = {};
                    for (const date in extraPayDates) {
                        const type = extraPayDates[date];
                        details[type] = (details[type] || 0) + 1;
                    }

                    let employeeExtraPaySummary = `${employeeName}: `;
                    const extraPayTypesPresent = Object.keys(details).filter(type => details[type] > 0);

                    if (extraPayTypesPresent.length > 0) {
                        hasExtraPay = true;
                        employeeExtraPaySummary += extraPayTypesPresent.map(type => `${type.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}: ${details[type]}`).join(', ');
                        const listItem = document.createElement('li');
                        listItem.textContent = employeeExtraPaySummary;
                        extraPayList.appendChild(listItem);
                    }
                }
                if (hasExtraPay) {
                    extraPayOutput.classList.remove('hidden');
                } else {
                    extraPayOutput.classList.add('hidden');
                }
            }


            /**
             * Generates shift insights using the Gemini API and applies them as tooltips.
             */
            async function generateShiftInsights() {
                showMessage('Generating shift insights, please wait...', 'info');
                generateShiftInsightsBtn.disabled = true;

                const prompt = `Provide a very brief description (1-2 sentences maximum) for each of the following control room shift types:
                - D (Day Shift)
                - N (Night Shift)
                - O (Off Day)
                
                Format the output as a JSON object where keys are the shift types (D, N, O) and values are their descriptions.`;

                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "D": { "type": "STRING" },
                                    "N": { "type": "STRING" },
                                    "O": { "type": "STRING" }
                                },
                                required: ["D", "N", "O"]
                            }
                        }
                    };
                    const apiKey = ""; // Canvas will provide this
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        
                        const jsonString = result.candidates[0].content.parts[0].text;
                        shiftDescriptions = JSON.parse(jsonString);
                        applyShiftDescriptions(); // Apply descriptions to the already generated roster
                        showMessage('Shift insights generated and applied as tooltips!', 'success');
                    } else {
                        showMessage('Failed to generate shift insights. Please try again.', 'error');
                        console.error('LLM response structure unexpected:', result);
                    }
                } catch (error) {
                    showMessage('Error generating shift insights. Please check your network connection or try again later.', 'error');
                    console.error('Error calling LLM:', error);
                } finally {
                    generateShiftInsightsBtn.disabled = false;
                }
            }

            /**
             * Exports the generated roster and summary to a CSV file.
             */
            function exportRosterToCsv() {
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                if (!startDate || !endDate) {
                    showMessage('Please generate a roster first before exporting.', 'error');
                    return;
                }

                const allEmployees = [
                    ...employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e)
                ];
                const uniqueEmployees = [...new Set(allEmployees)];

                if (uniqueEmployees.length === 0) {
                    showMessage('No employee data to export.', 'error');
                    return;
                }

                // Get shift patterns for CSV export
                const patternA = patternAInput.value.toUpperCase();
                const patternB = patternBInput.value.toUpperCase();
                const patternC = patternCInput.value.toUpperCase();

                // Re-generate roster data to ensure it's fresh for export
                const start = parseDateString(startDate);
                const end = parseDateString(endDate);
                const dates = [];
                let currentDate = new Date(start);
                while (currentDate <= end) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                let tempEmployeeShiftCounts = {}; // Use a temporary object for export

                // Simulate roster generation to populate tempEmployeeShiftCounts
                // This is a simplified version just to get the data for CSV
                const allShiftEmployees = {
                    'Shift A': employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    'Shift B': employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    'Shift C': employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e)
                };

                for (const shiftName in allShiftEmployees) {
                    const employeesInShift = allShiftEmployees[shiftName];
                    const currentPattern = shiftName === 'Shift A' ? patternA :
                                           shiftName === 'Shift B' ? patternB :
                                           patternC;

                    employeesInShift.forEach((employeeName) => {
                        if (!tempEmployeeShiftCounts[employeeName]) {
                            tempEmployeeShiftCounts[employeeName] = { 
                                D: 0, N: 0, O: 0, normalHours: 0,
                                totalSundays: 0, sundayHoursTimeAndAHalf: 0,
                                ...Object.fromEntries(ALL_LEAVE_TYPES.map(type => [type, 0])),
                                ...Object.fromEntries(ALL_EXTRA_PAY_TYPES.map(type => [type, 0]))
                            };
                        }

                        dates.forEach((date, dayIndex) => {
                            const dateString = formatDateToYYYYMMDD(date);
                            const isSunday = date.getDay() === 0;
                            const isPH = isPublicHoliday(dateString);

                            let isShiftAssigned = true;

                            // Check for Leave
                            if (employeeLeaveData[employeeName] && employeeLeaveData[employeeName][dateString]) {
                                const leaveType = employeeLeaveData[employeeName][dateString];
                                tempEmployeeShiftCounts[employeeName][leaveType]++;
                                isShiftAssigned = false;
                            } 
                            // Check for Extra Pay
                            else if (employeeExtraPayData[employeeName] && employeeExtraPayData[employeeName][dateString]) {
                                const extraPayType = employeeExtraPayData[employeeName][dateString];
                                tempEmployeeShiftCounts[employeeName][extraPayType]++;
                                isShiftAssigned = false;
                            }
                            
                            if (isShiftAssigned) {
                                // The dayIndexInCycle needs to be consistent for each employee for the pattern to apply correctly
                                // The current logic uses `uniqueEmployees.indexOf(employeeName) * pattern.length` to stagger the pattern.
                                // This ensures consistency across all employees for CSV export.
                                const dayIndexInCycle = (dayIndex + uniqueEmployees.indexOf(employeeName) * currentPattern.length) % currentPattern.length;
                                const shiftType = getShiftType(dayIndexInCycle, currentPattern);
                                
                                tempEmployeeShiftCounts[employeeName][shiftType]++;
                                if (shiftType === 'D' || shiftType === 'N') {
                                    tempEmployeeShiftCounts[employeeName].normalHours += 8;
                                    if (isSunday) {
                                        tempEmployeeShiftCounts[employeeName].totalSundays++;
                                        tempEmployeeShiftCounts[employeeName].sundayHoursTimeAndAHalf += 8;
                                    }
                                }
                            }
                        });
                    });
                }


                let csvContent = "data:text/csv;charset=utf-8,";

                // Roster Table Headers
                const rosterHeaders = ["Employee Name"];
                const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                dates.forEach(date => {
                    rosterHeaders.push(`${date.getDate()}/${(date.getMonth() + 1).toString().padStart(2, '0')} (${dayNames[date.getDay()]})`);
                });
                csvContent += rosterHeaders.join(",") + "\n";

                // Roster Table Data
                const allRosterEmployees = [
                    ...employeesATextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesBTextarea.value.split('\n').map(e => e.trim()).filter(e => e),
                    ...employeesCTextarea.value.split('\n').map(e => e.trim()).filter(e => e)
                ];
                const uniqueRosterEmployees = [...new Set(allRosterEmployees)]; // Ensure unique list for roster rows

                uniqueRosterEmployees.forEach(employeeName => {
                    const rowData = [employeeName];
                    dates.forEach((date, dayIndex) => {
                        const dateString = formatDateToYYYYMMDD(date);
                        let cellContent = '';

                        // Determine the shift group for the employee to get the correct pattern
                        let currentPatternForEmployee = '';
                        if (allShiftEmployees['Shift A'].includes(employeeName)) {
                            currentPatternForEmployee = patternA;
                        } else if (allShiftEmployees['Shift B'].includes(employeeName)) {
                            currentPatternForEmployee = patternB;
                        } else if (allShiftEmployees['Shift C'].includes(employeeName)) {
                            currentPatternForEmployee = patternC;
                        }
                        
                        let isShiftAssigned = true;

                        // Check for Leave
                        if (employeeLeaveData[employeeName] && employeeLeaveData[employeeName][dateString]) {
                            const leaveType = employeeLeaveData[employeeName][dateString];
                            cellContent = leaveType.toUpperCase().split(' ').map(word => word[0]).join(''); // Abbreviate leave type
                            isShiftAssigned = false;
                        } 
                        // Check for Extra Pay
                        else if (employeeExtraPayData[employeeName] && employeeExtraPayData[employeeName][dateString]) {
                            const extraPayType = employeeExtraPayData[employeeName][dateString];
                            cellContent = extraPayType.toUpperCase().split(' ').map(word => word[0]).join(''); // Abbreviate extra pay type
                            isShiftAssigned = false;
                        }

                        if (isShiftAssigned) {
                            // The cycle calculation for the roster needs to be consistent.
                            // Use the overall uniqueRosterEmployees index for consistent staggering across all employees
                            const dayIndexInCycle = (dayIndex + uniqueRosterEmployees.indexOf(employeeName) * currentPatternForEmployee.length) % currentPatternForEmployee.length;
                            cellContent = getShiftType(dayIndexInCycle, currentPatternForEmployee);
                        }
                        rowData.push(cellContent);
                    });
                    csvContent += rowData.join(",") + "\n";
                });

                csvContent += "\n\n"; // Separator between roster and summary

                // Summary Table Headers
                const summaryHeaders = ["Employee Name", "Day Shifts (D)", "Night Shifts (N)", "Off Days (O)", "Normal Hours", "Sundays Worked", "Sunday Hours (x1.5)"];
                ALL_LEAVE_TYPES.forEach(leaveType => {
                    summaryHeaders.push(`${leaveType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')} Days`);
                });
                ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                    summaryHeaders.push(`${extraPayType.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}`);
                });
                csvContent += summaryHeaders.join(",") + "\n";

                // Summary Table Data
                for (const employeeName in tempEmployeeShiftCounts) {
                    const data = tempEmployeeShiftCounts[employeeName];
                    const rowData = [ // Declare rowData here
                        employeeName,
                        data.D || 0,
                        data.N || 0,
                        data.O || 0,
                        data.normalHours || 0,
                        data.totalSundays || 0,
                        data.sundayHoursTimeAndAHalf || 0
                    ];
                    ALL_LEAVE_TYPES.forEach(leaveType => {
                        rowData.push(data[leaveType] || 0);
                    });
                    ALL_EXTRA_PAY_TYPES.forEach(extraPayType => {
                        rowData.push(data[extraPayType] || 0);
                    });
                    csvContent += rowData.join(",") + "\n";
                }

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "control_room_roster.csv");
                document.body.appendChild(link); // Required for Firefox
                link.click();
                document.body.removeChild(link); // Clean up
                showMessage('Roster exported to CSV successfully!', 'success');
            }

            /**
             * Clears all input fields and generated roster/summary.
             */
            function clearRoster() {
                startDateInput.value = '';
                endDateInput.value = '';
                employeesATextarea.value = '';
                employeesBTextarea.value = '';
                employeesCTextarea.value = '';
                patternAInput.value = 'DDDNNNOOO'; // Reset to default
                patternBInput.value = 'DDDNNNOOO'; // Reset to default
                patternCInput.value = 'DDDNNNOOO'; // Reset to default
                rosterOutputDiv.innerHTML = '';
                rosterOutputDiv.classList.add('hidden');
                rosterSummaryDiv.innerHTML = '';
                rosterSummaryDiv.classList.add('hidden');
                messageBox.classList.add('hidden'); // Hide message box

                // Clear leave and extra pay data and inputs
                employeeLeaveData = {};
                employeeLeaveCounts = {};
                employeeExtraPayData = {};
                leaveInputsContainer.innerHTML = '';
                extraPayInputsContainer.innerHTML = '';
                leaveCountOutput.classList.add('hidden');
                extraPayOutput.classList.add('hidden');
                leaveCountsList.innerHTML = '';
                extraPayList.innerHTML = '';
                shiftDescriptions = null; // Clear LLM descriptions

                showMessage('Roster data cleared.', 'info');
            }

            // Event Listeners
            generateRosterBtn.addEventListener('click', generateRoster);
            exportCsvBtn.addEventListener('click', exportRosterToCsv);
            generateShiftInsightsBtn.addEventListener('click', generateShiftInsights);
            clearRosterBtn.addEventListener('click', clearRoster);
            addLeaveEntryBtn.addEventListener('click', addLeaveEntry);
            applyAllLeaveBtn.addEventListener('click', applyAllLeave);
            addExtraPayEntryBtn.addEventListener('click', addExtraPayEntry);
            applyAllExtraPayBtn.addEventListener('click', applyAllExtraPay);
        });
    </script>
</body>
</html>
