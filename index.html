<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Room Roster Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general layout */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Dark slate gray text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            background-color: #ffffff; /* White container background */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 30px;
            width: 100%;
            max-width: 1200px; /* Max width for larger screens */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #1e293b; /* Darker title */
            text-align: center;
            margin-bottom: 20px;
            font-weight: 700; /* Bold font */
        }
        .input-group label {
            font-weight: 600; /* Semi-bold label */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input[type="date"],
        .input-group textarea,
        .input-group select { /* Added select for styling */
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 8px; /* Slightly rounded inputs */
            background-color: #f8fafc; /* Lighter input background */
            transition: all 0.2s ease-in-out;
        }
        .input-group input[type="date"]:focus,
        .input-group textarea:focus,
        .input-group select:focus { /* Added select for styling */
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Soft focus shadow */
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: #4f46e5; /* Indigo button */
            color: white;
            border: none;
        }
        .btn:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-1px); /* Slight lift effect */
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray button */
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        .roster-output {
            overflow-x: auto; /* Enable horizontal scrolling for the table */
            margin-top: 20px;
            border: 1px solid #e2e8f0; /* Light border around roster */
            border-radius: 8px;
        }
        .roster-table {
            width: 100%;
            border-collapse: collapse; /* Collapse table borders */
            min-width: 800px; /* Ensure minimum width for scrolling */
            margin-bottom: 20px; /* Space between multiple tables */
        }
        .roster-table th,
        .roster-table td {
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e2e8f0; /* Cell borders */
            white-space: nowrap; /* Prevent date/shift wrapping */
        }
        .roster-table thead th {
            background-color: #e0e7ff; /* Light indigo header */
            font-weight: 700;
            color: #374151;
            position: sticky; /* Sticky header for scrolling */
            top: 0;
            z-index: 10;
        }
        .roster-table tbody tr:nth-child(even) {
            background-color: #f8fafc; /* Zebra striping */
        }
        .roster-table tbody tr:hover {
            background-color: #eff6ff; /* Highlight row on hover */
        }
        .roster-table td:first-child {
            text-align: left; /* Align employee names to left */
            font-weight: 500;
            background-color: #e0e7ff; /* Light indigo for employee column */
            position: sticky; /* Sticky first column */
            left: 0;
            z-index: 10;
        }
        /* Adjust sticky header background for the first column */
        .roster-table th:first-child {
            background-color: #c7d2fe; /* Darker indigo for sticky corner */
            z-index: 11; /* Ensure it's above other sticky elements */
        }
        
        /* Message box styling */
        .message-box {
            background-color: #fff3cd; /* Light yellow background */
            border: 1px solid #ffeeba; /* Yellow border */
            color: #664d03; /* Dark yellow text */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            display: none; /* Hidden by default */
        }
        .message-box.show {
            display: block;
        }

        /* Sunday Highlight Styles */
        .sunday-column-header {
            background-color: #fecaca; /* Lighter red for header */
            color: #dc2626; /* Red text */
            font-weight: 700;
        }
        .sunday-column-cell {
            background-color: #fee2e2; /* Lightest red for data cells */
            color: #b91c1c; /* Darker red text */
        }

        /* Public Holiday Highlight Styles */
        .public-holiday-column-header {
            background-color: #fef3c7; /* Light orange/yellow for header */
            color: #d97706; /* Darker orange/yellow text */
            font-weight: 700;
        }
        .public-holiday-column-cell {
            background-color: #fefce8; /* Lightest orange/yellow for data cells */
            color: #b45309; /* Darker orange/yellow text */
        }

        /* Roster Summary Styles */
        .roster-summary {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0f9ff; /* Light blue background */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .roster-summary h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 15px;
            text-align: center;
        }
        .summary-table-container { /* New class for scrollability */
            overflow-x: auto;
            border-radius: 12px; /* Inherit border-radius from parent */
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px; /* Ensure minimum width for scrolling */
        }
        .summary-table th,
        .summary-table td {
            padding: 10px 15px;
            border: 1px solid #e2e8f0;
            text-align: left;
        }
        .summary-table thead th {
            background-color: #dbeafe; /* Lighter blue header */
            font-weight: 600;
            color: #1e40af;
        }
        .summary-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .summary-table tbody tr:hover {
            background-color: #e0f2fe;
        }
        /* Center calculation columns */
        .summary-table td:last-child,
        .summary-table td:nth-last-child(2),
        .summary-table td:nth-last-child(3),
        .summary-table td:nth-last-child(4),
        .summary-table td:nth-last-child(5), /* New: Extra Pay columns */
        .summary-table td:nth-last-child(6),
        .summary-table td:nth-last-child(7),
        .summary-table td:nth-last-child(8),
        .summary-table td:nth-last-child(9),
        .summary-table td:nth-last-child(10), /* Added for 'normal time' */
        .summary-table td:nth-last-child(11) { /* Added for 'Day&Night' */
            text-align: center;
            font-weight: 500;
        }

        /* Leave Type Styling */
        .leave-cell {
            font-weight: 600;
            color: white; /* Default text color for leave */
        }
        .leave-annual-leave { /* Corrected class name */
            background-color: #34d399; /* Green for Annual Leave ( Tailwind green-500) */
        }
        .leave-sick-leave { /* Corrected class name */
            background-color: #facc15; /* Yellow for Sick Leave (Tailwind yellow-400) */
            color: #334155; /* Dark text for readability on yellow */
        }
        .leave-family-responsibility { /* Corrected class name */
            background-color: #f97316; /* Orange for Family Responsibility (Tailwind orange-500) */
        }
        .leave-unpaid-leave { /* Corrected class name */
            background-color: #ef4444; /* Red for Unpaid Leave (Tailwind red-500) */
        }
        .leave-info {
            background-color: #60a5fa; /* Blue for general info/tooltip */
        }

        /* Extra Pay Styling */
        .extra-pay-cell {
            font-weight: 600;
            color: white;
            background-color: #a78bfa; /* Purple for general extra pay (Tailwind purple-400) */
        }
        .extra-pay-day-overtime {
            background-color: #818cf8; /* Light Blue/Indigo for Day OT (Tailwind indigo-400) */
        }
        .extra-pay-night-overtime {
            background-color: #4c1d95; /* Darker Purple for Night OT (Tailwind violet-800) */
        }
        .extra-pay-public-holiday-day-shift {
            background-color: #22c55e; /* Bright Green for PH Day (Tailwind green-500) */
        }
        .extra-pay-public-holiday-night-shift {
            background-color: #16a34a; /* Dark Green for PH Night (Tailwind green-700) */
        }
        .extra-pay-one-normal-time-and-one-o-t-2 {
            background-color: #ec4899; /* Pink for OT2 (Tailwind pink-500) */
        }
        /* New extra pay types */
        .extra-pay-day-night { /* Combined Day&Night */
            background-color: #a855f7; /* Violet for Day&Night (Tailwind violet-500) */
        }

        /* Dynamic row styling */
        .dynamic-input-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto; /* 3 columns for inputs, 1 for button */
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: end; /* Align items to the bottom */
        }
        .dynamic-input-row .input-group {
            margin-bottom: 0; /* Remove default margin from input-group */
        }
        .dynamic-input-row .remove-btn {
            padding: 10px 12px;
            background-color: #ef4444; /* Red */
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            height: 42px; /* Match input height */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dynamic-input-row .remove-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
    </style>
</head>
<body class="selection:bg-indigo-300">
    <div class="container">
        <h1 class="text-3xl sm:text-4xl">Control Room Roster Generator</h1>

        <div class="input-section grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="input-group">
                <label for="startDate">Roster Start Date:</label>
                <input type="date" id="startDate" class="form-input" min="" max="">
            </div>
            <div class="input-group">
                <label for="endDate">Roster End Date:</label>
                <input type="date" id="endDate" class="form-input" min="" max="">
            </div>
        </div>

        <div class="input-section grid grid-cols-1 md:grid-cols-3 gap-6 mt-6"> <!-- New section for shifts -->
            <div class="input-group">
                <label for="employeesA">Shift A Employees (One per line):</label>
                <textarea id="employeesA" rows="8" placeholder="Enter Shift A employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesB">Shift B Employees (One per line):</label>
                <textarea id="employeesB" rows="8" placeholder="Enter Shift B employee names here..." class="form-textarea"></textarea>
            </div>
            <div class="input-group">
                <label for="employeesC">Shift C Employees (One per line):</label>
                <textarea id="employeesC" rows="8" placeholder="Enter Shift C employee names here..." class="form-textarea"></textarea>
            </div>
        </div>

        <div class="button-group">
            <button id="generateRosterBtn" class="btn">Generate Roster</button>
            <button id="exportCsvBtn" class="btn">Export to CSV</button>
            <button id="generateShiftInsightsBtn" class="btn">Generate Shift Insights âœ¨</button> <!-- New LLM Button -->
            <button id="clearRosterBtn" class="btn btn-secondary">Clear Roster</button>
        </div>

        <div id="messageBox" class="message-box"></div>

        <!-- Leave Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Leave Management</h2>
            <div id="leaveInputsContainer">
                <!-- Dynamic leave input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addLeaveEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Leave Entry</button>
                <button id="applyAllLeaveBtn" class="btn bg-blue-500 hover:bg-blue-700 text-white">Apply All Leave</button>
            </div>
            <div id="leaveCountOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Leave Counts:</h3>
                <ul id="leaveCountsList" class="list-disc pl-5"></ul>
            </div>
        </div>

        <!-- Extra Pay Management Section -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Extra Pay Management</h2>
            <div id="extraPayInputsContainer">
                <!-- Dynamic extra pay input rows will be added here -->
            </div>
            <div class="flex gap-4 mt-4">
                <button id="addExtraPayEntryBtn" class="btn bg-gray-500 hover:bg-gray-700 text-white">Add Extra Pay Entry</button>
                <button id="applyAllExtraPayBtn" class="btn bg-purple-500 hover:bg-purple-700 text-white">Apply All Extra Pay</button>
            </div>
            <div id="extraPayOutput" class="mt-4 p-3 bg-gray-100 rounded-md hidden">
                <h3 class="text-lg font-medium mb-2">Extra Pay Details:</h3>
                <ul id="extraPayList" class="list-disc pl-5"></ul>
            </div>
        </div>


        <div id="rosterOutput" class="roster-output hidden">
            <!-- Roster table(s) will be generated here -->
        </div>

        <div id="rosterSummary" class="roster-summary hidden">
            <h2>Roster Summary</h2>
            <div id="summaryTableContainer" class="summary-table-container">
                <!-- Summary table will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variable to store shift descriptions from LLM
        let shiftDescriptions = null;

        // Global variables to store leave data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Leave Type" } }
        let employeeLeaveData = {};
        // Example: { "Employee Name": { "annual leave": 5, "sick leave": 2 } }
        let employeeLeaveCounts = {};

        // Global variable to store extra pay data
        // Example: { "Employee Name": { "YYYY-MM-DD": "Extra Pay Type" } }
        let employeeExtraPayData = {};

        // Define all possible extra pay types for summary table columns
        const ALL_EXTRA_PAY_TYPES = [
            'day overtime',
            'night overtime',
            'public holiday day shift',
            'public holiday night shift',
            'one normal time and one o/t 2',
            'Day&Night' // Modified extra pay type
        ];

        // South African Public Holidays (YYYY-MM-DD format) - Observed dates
        const SOUTH_AFRICAN_PUBLIC_HOLIDAYS = new Set([
            // 2025
            '2025-01-01', // New Year's Day
            '2025-03-21', // Human Rights Day
            '2025-04-18', // Good Friday
            '2025-04-21', // Family Day
            '2025-04-28', // Freedom Day (Observed, since 27th is Sunday)
            '2025-05-01', // Workers' Day
            '2025-06-16', // Youth Day
            '2025-08-11', // National Women's Day (Observed, since 9th is Saturday)
            '2025-09-24', // Heritage Day
            '2025-12-16', // Day of Reconciliation
            '2025-12-25', // Christmas Day
            '2025-12-26', // Day of Goodwill
            // 2026
            '2026-01-01', // New Year's Day
            '2026-03-23', // Human Rights Day (Observed, since 21st is Saturday)
            '2026-04-03', // Good Friday
            '2026-04-06', // Family Day
            '2026-04-27', // Freedom Day
            '2026-05-01', // Workers' Day
            '2026-06-16', // Youth Day
            '2026-08-10', // National Women's Day (Observed, since 9th is Sunday)
            '2026-09-24', // Heritage Day
            '2026-12-16', // Day of Reconciliation
            '2026-12-25', // Christmas Day
            '2026-12-26'  // Day of Goodwill
        ]);

        /**
         * Checks if a given date string is a South African public holiday.
         * @param {string} dateString - The date string in replete-MM-DD format.
         * @returns {boolean} True if it's a public holiday, false otherwise.
         */
        function isPublicHoliday(dateString) {
            return SOUTH_AFRICAN_PUBLIC_HOLIDAYS.has(dateString);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const employeesATextarea = document.getElementById('employeesA');
            const employeesBTextarea = document.getElementById('employeesB');
            const employeesCTextarea = document.getElementById('employeesC');

            const generateRosterBtn = document.getElementById('generateRosterBtn');
            const exportCsvBtn = document.getElementById('exportCsvBtn');
            const generateShiftInsightsBtn = document.getElementById('generateShiftInsightsBtn'); // New: LLM Button
            const clearRosterBtn = document.getElementById('clearRosterBtn');
            const rosterOutputDiv = document.getElementById('rosterOutput');
            const messageBox = document.getElementById('messageBox');
            const rosterSummaryDiv = document.getElementById('rosterSummary');
            const summaryTableContainer = document.getElementById('summaryTableContainer');

            // Leave Management DOM elements
            const leaveInputsContainer = document.getElementById('leaveInputsContainer');
            const addLeaveEntryBtn = document.getElementById('addLeaveEntryBtn');
            const applyAllLeaveBtn = document.getElementById('applyAllLeaveBtn');
            const leaveCountOutput = document.getElementById('leaveCountOutput');
            const leaveCountsList = document.getElementById('leaveCountsList');

            // Extra Pay Management DOM elements
            const extraPayInputsContainer = document.getElementById('extraPayInputsContainer');
            const addExtraPayEntryBtn = document.getElementById('addExtraPayEntryBtn');
            const applyAllExtraPayBtn = document.getElementById('applyAllExtraPayBtn');
            const extraPayOutput = document.getElementById('extraPayOutput');
            const extraPayList = document.getElementById('extraPayList');


            // Set min date to 2025-01-01
            const overallMinDate = `2025-01-01`;
            // Max date is December 31st of the next year from the current year
            const currentYear = new Date().getFullYear();
            const nextYear = currentYear + 1;
            const overallMaxDate = `${nextYear}-12-31`;

            startDateInput.setAttribute('min', overallMinDate);
            startDateInput.setAttribute('max', overallMaxDate);
            endDateInput.setAttribute('min', overallMinDate);
            endDateInput.setAttribute('max', overallMaxDate);

            // Set employee textareas to be blank by default
            employeesATextarea.value = '';
            employeesBTextarea.value = '';
            employeesCTextarea.value = '';

            /**
             * Helper function to parse a replete-MM-DD string into a Date object in local time.
             * @param {string} dateString - The date string in replete-MM-DD format.
             * @returns {Date} A Date object representing the date in local time.
             */
            function parseDateString(dateString) {
                const [year, month, day] = dateString.split('-').map(Number);
                // Month is 0-indexed in JavaScript Date constructor
                return new Date(year, month - 1, day);
            }

            /**
             * Helper function to format a Date object into a replete-MM-DD string in local time.
             * @param {Date} date - The Date object to format.
             * @returns {string} The date string in replete-MM-DD format.
             */
            function formatDateToYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
                const day = date.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Event listener to ensure endDate is not before startDate
            startDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        // Adjust endDate to be a reasonable date after startDate, e.g., 15th of next month
                        const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                        endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                        showMessage('End date adjusted to be after start date.', 'info');
                    }
                } else if (startDateInput.value && !endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const newEndDate = new Date(start.getFullYear(), start.getMonth() + 1, 15);
                    endDateInput.value = formatDateToYYYYMMDD(newEndDate);
                }
                endDateInput.setAttribute('min', startDateInput.value);
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
            });

            endDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    const start = parseDateString(startDateInput.value);
                    const end = parseDateString(endDateInput.value);
                    if (start > end) {
                        showMessage('End date cannot be before start date. Please correct.', 'error');
                        endDateInput.value = '';
                    }
                }
                // Update min/max dates for dynamically added rows
                updateDynamicRowDateConstraints();
            });

            /**
             * Updates the min/max attributes for date inputs in dynamic rows.
             */
            function updateDynamicRowDateConstraints() {
                const minDate = startDateInput.value;
                const maxDate = endDateInput.value;

                document.querySelectorAll('.dynamic-input-row input[type="date"]').forEach(input => {
                    input.setAttribute('min', minDate);
                    input.setAttribute('max', maxDate);
                });
            }


            /**
             * Displays a message in the message box.
             * @param {string} message - The message to display.
             * @param {string} type - The type of message (e.g., 'error', 'info', 'success', 'warning').
             */
            function showMessage(message, type = 'info') {
                messageBox.textContent = message;
                messageBox.className = 'message-box show';
                // Clear previous type classes
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                
                if (type === 'error') {
                    messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
                } else if (type === 'success') {
                    messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
                } else if (type === 'warning') {
                    messageBox.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                } else {
                    messageBox.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
                }
                setTimeout(() => {
                    hideMessage();
                }, 5000);
            }

            /**
             * Hides the message box.
             */
            function hideMessage() {
                messageBox.className = 'message-box';
                messageBox.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
            }


            /**
             * Determines the shift type (D, N, O) based on the day's index within the 9-day cycle.
             * @param {number} dayIndexInCycle - The 0-indexed day within the 9-day cycle (0-8).
             * @returns {string} The shift type ('D', 'N', or 'O').
             */
            function getShiftType(dayIndexInCycle) {
                // The pattern is 3 days, 3 nights, 3 offs
                const shifts = ["D", "D", "D", "N", "N", "N", "O", "O", "O"];
                return shifts[dayIndexInCycle % shifts.length];
            }

            /**
             * Applies LLM-generated shift descriptions as tooltips to the roster cells.
             */
            function applyShiftDescriptions() {
                if (!shiftDescriptions) {
                    return; // No descriptions to apply
                }
                const shiftCells = rosterOutputDiv.querySelectorAll('.roster-table tbody td');
                shiftCells.forEach(cell => {
                    // Only apply tooltip if it's a shift, not a leave or extra pay
                    if (!cell.classList.contains('leave-cell') && !cell.classList.contains('extra-pay-cell')) {
                        const shiftType = cell.textContent.trim();
                        if (shiftDescriptions[shiftType]) {
                            cell.setAttribute('title', shiftDescriptions[shiftType]);
                        }
                    }
                });
            }

            /**
             * Generates a single roster table for a given set of employees.
             * @param {Array<string>} employees - List of employee names for this shift.
             * @param {Array<Date>} dates - List of dates in the roster period.
             * @param {Object} currentEmployeeShiftCounts - Object to accumulate shift counts for all employees.
             * @param {string} shiftName - The name of the shift (e.g., "Shift A").
             * @returns {string} The HTML string for the generated roster table.
             */
            function generateSingleRosterTable(employees, dates, currentEmployeeShiftCounts, shiftName) {
                // Array for short day names (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
                const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

                let tableHTML = `<h3 class="text-xl font-semibold mb-2 mt-4 text-center">${shiftName} Roster</h3>`;
                tableHTML += `<table class="roster-table"><thead>`;
                
                // First header row for "Employee Name" and Dates
                tableHTML += `<tr><th class="employee-header" rowspan="2">Employee Name</th>`; // rowspan for employee header
                dates.forEach(date => {
                    // Check if the current date is a Sunday or Public Holiday
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const isPH = isPublicHoliday(dateString);

                    let headerHighlightClass = '';
                    if (isSunday) {
                        headerHighlightClass += ' sunday-column-header';
                    }
                    if (isPH) {
                        headerHighlightClass += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${headerHighlightClass.trim()}">${date.getDate()}/${(date.getMonth() + 1).toString().padStart(2, '0')}</th>`;
                });
                tableHTML += `</tr>`;

                // Second header row for Day of the Week
                tableHTML += `<tr>`;
                dates.forEach(date => {
                    const dateString = formatDateToYYYYMMDD(date);
                    const isSunday = date.getDay() === 0; // 0 is Sunday
                    const isPH = isPublicHoliday(dateString);

                    let highlightClass = '';
                    if (isSunday) {
                        highlightClass += ' sunday-column-header';
                    }
                    if (isPH) {
                        highlightClass += ' public-holiday-column-header';
                    }
                    tableHTML += `<th class="${highlightClass.trim()}">${dayNames[date.getDay()]}</th>`;
                });
                tableHTML += `</tr></thead><tbody>`;

                // Add rows for each employee in this shift
                employees.forEach((employeeName) => {
                    // Ensure employee entry exists in currentEmployeeShiftCounts
                    if (!currentEmployeeShiftCounts[employeeName]) {
                        currentEmployeeShiftCounts[employeeName] = { 
                            D: 0, N: 0, O: 0, normalHours: 0,
                            totalSundays: 0, sundayHoursTimeAndAHalf: 0,
                            'annual leave': 0, 'sick leave': 0, 'family responsibility': 0, 'unpaid leave': 0,
                            'normalTime': 0, 'publicHolidays': 0 
                        }; 
                        ALL_EXTRA_PAY_TYPES.forEach(type => {
                            currentEmployeeShiftCounts[employeeName][type] = 0;
                        });
                    }

                    tableHTML += `<tr><td class="employee-name">${employeeName}</td>`;
                    dates.forEach(date => {
                        const dateString = formatDateToYYYYMMDD(date); 
                        let cellContent = '';
                        let cellClass = '';
                        let cellTitle = '';

                        // Check if it's a public holiday for this specific cell
                        const isPH = isPublicHoliday(dateString);
                        if (isPH) {
                            // Only increment if this employee is actually working (not on leave or extra pay)
                            if (!employeeLeaveData[employeeName]?.[dateString] && !employeeExtraPayData[employeeName]?.[dateString]) {
                                currentEmployeeShiftCounts[employeeName]['publicHolidays']++; 
                            }
                        }

                        // Priority: Leave > Extra Pay > Regular Shift
                        if (employeeLeaveData[employeeName] && employeeLeaveData[employeeName][dateString]) {
                            const leaveType = employeeLeaveData[employeeName][dateString];
                            let displayCode = '';
                            switch (leaveType) {
                                case 'annual leave': displayCode = 'AL'; break;
                                case 'sick leave': displayCode = 'SL'; break;
                                case 'family responsibility': displayCode = 'FRL'; break;
                                case 'unpaid leave': displayCode = 'UL'; break;
                                default: displayCode = 'L';
                            }
                            cellContent = displayCode;
                            cellClass = `leave-cell leave-${leaveType.replace(/\s/g, '-')}`; 
                            cellTitle = `Leave: ${leaveType.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}`; 
                            currentEmployeeShiftCounts[employeeName][leaveType]++;

                        } else if (employeeExtraPayData[employeeName] && employeeExtraPayData[employeeName][dateString]) {
                            const extraPayType = employeeExtraPayData[employeeName][dateString];
                            let displayCode = '';
                            switch (extraPayType) {
                                case 'day overtime': displayCode = 'DO'; break;
                                case 'night overtime': displayCode = 'NO'; break;
                                case 'public holiday day shift': displayCode = 'PHD'; break;
                                case 'public holiday night shift': displayCode = 'PHN'; break;
                                case 'one normal time and one o/t 2': displayCode = 'OT2'; break;
                                case 'Day&Night': displayCode = 'D&N'; break;
                                default: displayCode = 'EP';
                            }
                            cellContent = displayCode;
                            cellClass = `extra-pay-cell extra-pay-${extraPayType.replace(/[^a-zA-Z0-9-]/g, '').toLowerCase()}`;
                            cellTitle = `Extra Pay: ${extraPayType.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ').replace('&', '&')}`;
                            currentEmployeeShiftCounts[employeeName][extraPayType]++;
                            if (extraPayType === 'Day&Night') {
                                currentEmployeeShiftCounts[employeeName]['normalTime']++;
                            }

                        } else {
                            // Regular shift
                            const diffTime = Math.abs(date.getTime() - dates[0].getTime()); // Calculate relative to the first date of the roster
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            const dayIndexInCycle = diffDays % 9;
                            const shift = getShiftType(dayIndexInCycle);
                            cellContent = shift;
                            currentEmployeeShiftCounts[employeeName][shift]++;
                            if (shift === 'D' || shift === 'N') {
                                currentEmployeeShiftCounts[employeeName]['normalTime']++;
                            }
                        }

                        const isSunday = date.getDay() === 0; // 0 is Sunday
                        let cellDateClass = '';
                        if (isSunday) {
                            cellDateClass += ' sunday-column-cell';
                        }
                        if (isPH) {
                            cellDateClass += ' public-holiday-column-cell';
                        }
                        tableHTML += `<td class="${cellClass} ${cellDateClass.trim()}" title="${cellTitle}">${cellContent}</td>`;
                    });
                    // Recalculate normal hours after all shifts for the employee are counted
                    currentEmployeeShiftCounts[employeeName].normalHours = (currentEmployeeShiftCounts[employeeName].D + currentEmployeeShiftCounts[employeeName].N) * 12; 
                    tableHTML += `</tr>`;
                });

                tableHTML += `</tbody></table>`;
                return tableHTML;
            }


            /**
             * Generates the roster based on the input start date and employees.
             */
            function generateRoster() {
                hideMessage();

                const startDateStr = startDateInput.value;
                const endDateStr = endDateInput.value;
                const employeesA = employeesATextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');
                const employeesB = employeesBTextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');
                const employeesC = employeesCTextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');

                const allEmployees = [...employeesA, ...employeesB, ...employeesC];

                if (!startDateStr || !endDateStr) {
                    showMessage('Please select both a start and an end date for the roster.', 'error');
                    return;
                }
                if (allEmployees.length === 0) {
                    showMessage('Please enter employee names for at least one shift.', 'error');
                    return;
                }

                const startDate = parseDateString(startDateStr);
                const endDate = parseDateString(endDateStr);

                if (startDate > endDate) {
                    showMessage('The start date cannot be after the end date. Please correct.', 'error');
                    return;
                }

                const dates = [];
                let currentDate = new Date(startDate);

                while (currentDate <= endDate) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                if (dates.length === 0) {
                    showMessage('No dates to generate. Please check your start and end dates.', 'error');
                    return;
                }

                // Reset employeeShiftCounts for fresh calculation
                employeeLeaveCounts = {}; // Clear previous leave counts before recalculating
                const currentEmployeeShiftCounts = {}; // Use a temporary object for this generation cycle

                // Initialize counts for all employees across all shifts
                allEmployees.forEach(employeeName => {
                    currentEmployeeShiftCounts[employeeName] = { 
                        D: 0, 
                        N: 0, 
                        O: 0, 
                        normalHours: 0,
                        totalSundays: 0, 
                        sundayHoursTimeAndAHalf: 0,
                        'annual leave': 0,
                        'sick leave': 0,
                        'family responsibility': 0,
                        'unpaid leave': 0,
                        'normalTime': 0,
                        'publicHolidays': 0 
                    }; 
                    ALL_EXTRA_PAY_TYPES.forEach(type => {
                        currentEmployeeShiftCounts[employeeName][type] = 0;
                    });
                });

                let allRostersHTML = '';

                // Generate roster for Shift A
                if (employeesA.length > 0) {
                    allRostersHTML += generateSingleRosterTable(employeesA, dates, currentEmployeeShiftCounts, "Shift A");
                }
                // Generate roster for Shift B
                if (employeesB.length > 0) {
                    allRostersHTML += generateSingleRosterTable(employeesB, dates, currentEmployeeShiftCounts, "Shift B");
                }
                // Generate roster for Shift C
                if (employeesC.length > 0) {
                    allRostersHTML += generateSingleRosterTable(employeesC, dates, currentEmployeeShiftCounts, "Shift C");
                }

                rosterOutputDiv.innerHTML = allRostersHTML;
                rosterOutputDiv.classList.remove('hidden');

                // Apply descriptions if already generated
                applyShiftDescriptions();

                // Generate and display summary table using currentEmployeeShiftCounts
                let summaryHTML = `<table class="summary-table"><thead><tr><th>Employee Name</th><th>Normal Time</th><th>Total Day Shifts (D)</th><th>Total Night Shifts (N)</th><th>Total Off Days (O)</th><th>Normal Hours Total</th><th>Total Sundays</th><th>Sunday Hours Time and a Half</th><th>Public Holidays</th><th>Annual Leave</th><th>Sick Leave</th><th>Family Responsibility</th><th>Unpaid Leave</th>`; 
                
                // Add Extra Pay Type headers dynamically
                ALL_EXTRA_PAY_TYPES.forEach(type => {
                    const formattedType = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ').replace('&', '&');
                    summaryHTML += `<th>${formattedType}</th>`;
                });
                summaryHTML += `</tr></thead><tbody>`;

                for (const employeeName of allEmployees) { 
                    const counts = currentEmployeeShiftCounts[employeeName];
                    // Recalculate total Sundays and Sunday hours for summary based on actual shifts assigned
                    let employeeSundays = 0;
                    dates.forEach(date => {
                        const dateString = formatDateToYYYYMMDD(date);
                        if (date.getDay() === 0 && !employeeLeaveData[employeeName]?.[dateString] && !employeeExtraPayData[employeeName]?.[dateString]) {
                            // Only count as a Sunday if it's a regular shift day for the employee
                            employeeSundays++;
                        }
                    });
                    counts.totalSundays = employeeSundays;
                    counts.sundayHoursTimeAndAHalf = employeeSundays * 18;


                    summaryHTML += `<tr><td>${employeeName}</td><td>${counts['normalTime']}</td><td>${counts.D}</td><td>${counts.N}</td><td>${counts.O}</td><td>${counts.normalHours}</td><td>${counts.totalSundays}</td><td>${counts.sundayHoursTimeAndAHalf}</td><td>${counts['publicHolidays']}</td><td>${counts['annual leave']}</td><td>${counts['sick leave']}</td><td>${counts['family responsibility']}</td><td>${counts['unpaid leave']}</td>`; 
                    
                    // Add Extra Pay Type counts dynamically
                    ALL_EXTRA_PAY_TYPES.forEach(type => {
                        summaryHTML += `<td>${counts[type] || 0}</td>`;
                    });
                    summaryHTML += `</tr>`;
                }
                summaryHTML += `</tbody></table>`;
                summaryTableContainer.innerHTML = summaryHTML;
                rosterSummaryDiv.classList.remove('hidden');

                showMessage('Roster generated successfully!', 'success');
                populateEmployeeDropdowns(); // Populate both employee dropdowns after roster generation
                displayLeaveCounts(); // Update leave counts display
                displayExtraPayDetails(); // Update extra pay display
            }

            /**
             * Clears the generated roster and input fields.
             */
            function clearRoster() {
                rosterOutputDiv.innerHTML = '';
                rosterOutputDiv.classList.add('hidden');
                rosterSummaryDiv.classList.add('hidden'); // Hide summary div
                summaryTableContainer.innerHTML = ''; // Clear summary content
                // Set date inputs to blank
                startDateInput.value = '';
                endDateInput.value = '';
                employeesATextarea.value = ''; // Clear all three textareas
                employeesBTextarea.value = '';
                employeesCTextarea.value = '';
                shiftDescriptions = null; // Clear cached descriptions
                employeeLeaveData = {}; // Clear leave data
                employeeLeaveCounts = {}; // Clear leave counts
                employeeExtraPayData = {}; // Clear extra pay data
                
                // Clear dynamic input rows
                leaveInputsContainer.innerHTML = '';
                extraPayInputsContainer.innerHTML = '';

                populateEmployeeDropdowns(); // Clear employee dropdowns
                displayLeaveCounts(); // Clear leave counts display
                displayExtraPayDetails(); // Clear extra pay display
                hideMessage();
                showMessage('Roster cleared.', 'info');
            }

            /**
             * Exports the generated roster table to a CSV file.
             */
            function exportRosterToCSV() {
                const tables = rosterOutputDiv.querySelectorAll('table');
                if (tables.length === 0) {
                    showMessage('No roster generated yet to export!', 'error');
                    return;
                }

                let csv = [];

                tables.forEach(table => {
                    // Add a blank line to separate tables in CSV
                    if (csv.length > 0) {
                        csv.push(''); 
                    }

                    // Add shift name header if available (from the h3 tag before the table)
                    const prevSibling = table.previousElementSibling;
                    if (prevSibling && prevSibling.tagName === 'H3') {
                        csv.push(`"${prevSibling.textContent.trim()}"`);
                    }

                    const rows = table.querySelectorAll('tr');

                    // Manually construct CSV to include both header rows
                    const headerRow1 = [];
                    const headerRow2 = [];

                    // Get headers from the first two rows of the table
                    const headerCells1 = rows[0].querySelectorAll('th');
                    const headerCells2 = rows[1].querySelectorAll('th');

                    // First header row (Employee Name and Dates)
                    headerCells1.forEach((cell, index) => {
                        let text = cell.innerText.trim();
                        if (index === 0) { // Employee Name cell
                            headerRow1.push(text);
                            headerRow2.push(''); // Empty cell for day of week under Employee Name
                        } else {
                            if (text.includes(',')) text = `"${text.replace(/"/g, '""')}"`;
                            headerRow1.push(text);
                        }
                    });
                    csv.push(headerRow1.join(','));

                    // Second header row (Day of the Week)
                    headerCells2.forEach(cell => {
                        let text = cell.innerText.trim();
                        if (text.includes(',')) text = `"${text.replace(/"/g, '""')}"`;
                        headerRow2.push(text);
                    });
                    csv.push(headerRow2.join(','));


                    // Iterate over data rows (starting from index 2, as 0 and 1 are headers)
                    for (let i = 2; i < rows.length; i++) {
                        const row = rows[i];
                        const cols = row.querySelectorAll('td');
                        const rowData = [];
                        cols.forEach(col => {
                            let text = col.innerText.trim();
                            // If the cell has a title (meaning it's a leave or extra pay day), use the title for CSV
                            const title = col.getAttribute('title');
                            if (title && (title.startsWith('Leave: ') || title.startsWith('Extra Pay: '))) {
                                text = title.replace('Leave: ', '').replace('Extra Pay: ', ''); // Use the full type for CSV
                            }
                            if (text.includes(',')) {
                                text = `"${text.replace(/"/g, '""')}"`;
                            }
                            rowData.push(text);
                        });
                        csv.push(rowData.join(','));
                    }
                });


                // Add summary data to CSV
                const summaryTable = summaryTableContainer.querySelector('table');
                if (summaryTable) {
                    csv.push('\n'); // Add a blank line for separation
                    csv.push('Roster Summary'); // Add a header for the summary section

                    const summaryRows = summaryTable.querySelectorAll('tr');
                    summaryRows.forEach(sRow => {
                        const sCols = sRow.querySelectorAll('th, td');
                        const sRowData = [];
                        sCols.forEach(sCol => {
                            let sText = sCol.innerText.trim();
                            if (sText.includes(',')) {
                                sText = `"${sText.replace(/"/g, '""')}"`;
                            }
                            sRowData.push(sText);
                        });
                        csv.push(sRowData.join(','));
                    });
                }

                // Add Extra Pay Details to CSV
                if (!extraPayOutput.classList.contains('hidden') && extraPayList.children.length > 0) {
                    csv.push('\n');
                    csv.push('Extra Pay Details');
                    const extraPayItems = extraPayList.querySelectorAll('li');
                    extraPayItems.forEach(item => {
                        let text = item.textContent.trim();
                        if (text.includes(',')) {
                            text = `"${text.replace(/"/g, '""')}"`;
                        }
                        csv.push(text);
                    });
                }


                const csvString = csv.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', 'control_room_roster.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                showMessage('Roster exported to CSV!', 'success');
            }

            /**
             * Calls the Gemini API to get shift descriptions.
             */
            async function generateShiftInsights() {
                showMessage('Generating shift insights... Please wait.', 'info');
                try {
                    const prompt = "You are a helpful assistant for a control room. Provide a very concise, single-sentence description for each of the following shift types: 'D' for Day Shift, 'N' for Night Shift, and 'O' for Off Day. Focus on typical duties or status for a control room environment. Format your response as a JSON object with keys 'D', 'N', 'O' and their corresponding descriptions as values. Example: { \"D\": \"Description for Day Shift\", \"N\": \"Description for Night Shift\", \"O\": \"Description for Off Day\" }";
                    
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "D": { "type": "STRING" },
                                    "N": { "type": "STRING" },
                                    "O": { "type": "STRING" }
                                },
                                "propertyOrdering": ["D", "N", "O"]
                            }
                        }
                    };

                    const apiKey = ""; // Canvas will automatically provide this in runtime
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        try {
                            shiftDescriptions = JSON.parse(jsonText);
                            showMessage('Shift insights generated successfully! Hover over shifts to see descriptions.', 'success');
                            // If roster is already generated, apply descriptions immediately
                            if (!rosterOutputDiv.classList.contains('hidden')) {
                                applyShiftDescriptions();
                            }
                        } catch (parseError) {
                            console.error('Failed to parse LLM response:', parseError);
                            showMessage('Failed to parse shift insights. Unexpected format from AI.', 'error');
                            shiftDescriptions = null;
                        }
                    } else {
                        showMessage('No shift insights received from AI. Please try again.', 'error');
                        shiftDescriptions = null;
                    }

                } catch (error) {
                    console.error('Error generating shift insights:', error);
                    showMessage(`Error generating shift insights: ${error.message}`, 'error');
                    shiftDescriptions = null;
                }
            }

            // --- Leave Management Functions ---

            /**
             * Creates and appends a new leave input row.
             */
            function createLeaveInputRow(initialEmployee = '') {
                const row = document.createElement('div');
                row.classList.add('dynamic-input-row');

                row.innerHTML = `
                    <div class="input-group">
                        <label for="leaveEmployeeSelect" class="block text-sm font-medium text-gray-700">Employee:</label>
                        <select class="employee-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="">-- Select an Employee --</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="leaveTypeSelect" class="block text-sm font-medium text-gray-700">Leave Type:</label>
                        <select class="leave-type-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="annual leave">Annual Leave</option>
                            <option value="sick leave">Sick Leave</option>
                            <option value="family responsibility">Family Responsibility Leave</option>
                            <option value="unpaid leave">Unpaid Leave</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="leaveDate" class="block text-sm font-medium text-gray-700">Date:</label>
                        <input type="date" class="leave-date-input mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;

                const employeeSelect = row.querySelector('.employee-select');
                const dateInput = row.querySelector('.leave-date-input');
                const removeBtn = row.querySelector('.remove-btn');

                // Populate employee dropdown in this new row
                populateEmployeeDropdownInSingleSelect(employeeSelect, initialEmployee);
                
                // IMPORTANT: Call updateDynamicRowDateConstraints for the new row's date input
                dateInput.setAttribute('min', startDateInput.value);
                dateInput.setAttribute('max', endDateInput.value);

                removeBtn.addEventListener('click', () => {
                    const employeeName = employeeSelect.value;
                    const dateToRemove = dateInput.value;

                    // Remove from global data if it exists
                    if (employeeName && dateToRemove && employeeLeaveData[employeeName] && employeeLeaveData[employeeName][dateToRemove]) {
                        delete employeeLeaveData[employeeName][dateToRemove];
                        // If no more leave for this employee, remove employee entry from data
                        if (Object.keys(employeeLeaveData[employeeName]).length === 0) {
                            delete employeeLeaveData[employeeName];
                        }
                        showMessage(`Removed leave for ${employeeName} on ${dateToRemove}.`, 'info');
                        generateRoster(); // Regenerate roster to reflect removal
                    } else {
                        showMessage('No specific leave record found to remove for this row, just removing the input row.', 'info');
                    }
                    row.remove(); // Remove the HTML row
                    displayLeaveCounts(); // Update leave counts display
                });

                leaveInputsContainer.appendChild(row);
                return row; // Return the created row for potential further manipulation
            }

            /**
             * Populates a single employee select dropdown.
             * @param {HTMLSelectElement} selectElement - The select element to populate.
             * @param {string} selectedValue - The value to pre-select.
             */
            function populateEmployeeDropdownInSingleSelect(selectElement, selectedValue = '') {
                const employeesA = employeesATextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');
                const employeesB = employeesBTextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');
                const employeesC = employeesCTextarea.value.trim().split('\n').map(name => name.trim()).filter(name => name !== '');
                const allEmployees = [...employeesA, ...employeesB, ...employeesC];

                selectElement.innerHTML = '<option value="">-- Select an Employee --</option>';
                allEmployees.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selectElement.appendChild(option);
                });

                if (selectedValue) {
                    selectElement.value = selectedValue;
                }
            }

            /**
             * Populates all employee dropdowns (initial and dynamic).
             */
            function populateEmployeeDropdowns() {
                document.querySelectorAll('#leaveInputsContainer .employee-select').forEach(select => {
                    populateEmployeeDropdownInSingleSelect(select, select.value); // Re-populate, keeping current selection
                });
                document.querySelectorAll('#extraPayInputsContainer .employee-select').forEach(select => {
                    populateEmployeeDropdownInSingleSelect(select, select.value); // Re-populate, keeping current selection
                });
            }

            /**
             * Applies all leave entries from dynamic rows.
             */
            function applyAllLeaveEntries() {
                let anyApplied = false;
                let hasOverallError = false; 
                let errorMessages = []; // Initialize errorMessages here

                // Create a temporary object to hold all new valid leave data
                const tempEmployeeLeaveData = {};

                const leaveRows = leaveInputsContainer.querySelectorAll('.dynamic-input-row');
                if (leaveRows.length === 0) {
                    showMessage('No leave entries to apply.', 'warning');
                    return;
                }

                for (const row of leaveRows) { 
                    const employeeSelect = row.querySelector('.employee-select');
                    const leaveTypeSelect = row.querySelector('.leave-type-select');
                    const leaveDateInput = row.querySelector('.leave-date-input');

                    const selectedEmployee = employeeSelect.value;
                    const selectedLeaveType = leaveTypeSelect.value;
                    const selectedDateStr = leaveDateInput.value; 

                    if (!selectedEmployee || selectedEmployee === "" || !selectedLeaveType || selectedLeaveType === "" || !selectedDateStr) {
                        errorMessages.push('Please fill all fields in each leave entry row.');
                        hasOverallError = true;
                        continue; 
                    }

                    const rosterStartDate = parseDateString(startDateInput.value);
                    const rosterEndDate = parseDateString(endDateInput.value);
                    const leaveDate = parseDateString(selectedDateStr); 

                    if (leaveDate < rosterStartDate || leaveDate > rosterEndDate) {
                        errorMessages.push(`Leave date ${selectedDateStr} for ${selectedEmployee} is outside the roster period.`);
                        hasOverallError = true;
                        continue; 
                    }

                    if (!tempEmployeeLeaveData[selectedEmployee]) {
                        tempEmployeeLeaveData[selectedEmployee] = {};
                    }
                    tempEmployeeLeaveData[selectedEmployee][selectedDateStr] = selectedLeaveType; 
                    anyApplied = true;
                }

                if (hasOverallError && errorMessages.length > 0) { 
                    showMessage(`Some leave entries could not be applied: ${errorMessages.join('; ')}`, 'error');
                    return;
                }

                employeeLeaveData = tempEmployeeLeaveData;
                console.log('DEBUG: employeeLeaveData after applying all:', JSON.stringify(employeeLeaveData));


                if (anyApplied) {
                    showMessage('All valid leave entries applied. Roster updated.', 'success');
                    generateRoster(); 
                } else if (!hasOverallError) { 
                    showMessage('No new valid leave entries were found to apply.', 'info');
                }
            }

            /**
             * Displays the total counts for each leave type per employee, including dates.
             */
            function displayLeaveCounts() {
                leaveCountsList.innerHTML = ''; // Clear previous counts
                let hasLeaveData = false;

                for (const employee in employeeLeaveData) { // Iterate through employeeLeaveData to get dates
                    const employeeDates = employeeLeaveData[employee];
                    const leaveTypesWithDates = {
                        'annual leave': [],
                        'sick leave': [],
                        'family responsibility': [],
                        'unpaid leave': []
                    };

                    for (const date in employeeDates) {
                        const type = employeeDates[date];
                        if (leaveTypesWithDates[type]) {
                            leaveTypesWithDates[type].push(date);
                        }
                    }

                    let employeeHasLeave = false;
                    const employeeSummaryItems = [];

                    for (const type in leaveTypesWithDates) {
                        if (leaveTypesWithDates[type].length > 0) {
                            employeeHasLeave = true;
                            hasLeaveData = true;
                            const formattedType = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                            const datesList = leaveTypesWithDates[type].sort().join(', '); // Sort dates for readability
                            employeeSummaryItems.push(`${formattedType} (${leaveTypesWithDates[type].length} days): ${datesList}`);
                        }
                    }

                    if (employeeHasLeave) {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `<strong>${employee}:</strong><br> ${employeeSummaryItems.join('<br>')}`;
                        leaveCountsList.appendChild(listItem);
                    }
                }

                if (hasLeaveData) {
                    leaveCountOutput.classList.remove('hidden');
                } else {
                    leaveCountOutput.classList.add('hidden');
                }
            }

            // --- Extra Pay Management Functions ---

            /**
             * Creates and appends a new extra pay input row.
             */
            function createExtraPayInputRow(initialEmployee = '') {
                const row = document.createElement('div');
                row.classList.add('dynamic-input-row');

                row.innerHTML = `
                    <div class="input-group">
                        <label for="extraPayEmployeeSelect" class="block text-sm font-medium text-gray-700">Employee:</label>
                        <select class="employee-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="">-- Select an Employee --</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="extraPayTypeSelect" class="block text-sm font-medium text-gray-700">Extra Pay Type:</label>
                        <select class="extra-pay-type-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="day overtime">Day Overtime</option>
                            <option value="night overtime">Night Overtime</option>
                            <option value="public holiday day shift">Public Holiday Day Shift</option>
                            <option value="public holiday night shift">Public Holiday Night Shift</option>
                            <option value="one normal time and one o/t 2">One Normal Time and One O/T 2</option>
                            <option value="Day&Night">Day&Night</option> <!-- Updated option -->
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="extraPayDate" class="block text-sm font-medium text-gray-700">Date:</label>
                        <input type="date" class="extra-pay-date-input mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    </div>
                    <button type="button" class="remove-btn">Remove</button>
                `;
                const employeeSelect = row.querySelector('.employee-select');
                const dateInput = row.querySelector('.extra-pay-date-input');
                const removeBtn = row.querySelector('.remove-btn');

                // Populate employee dropdown in this new row
                populateEmployeeDropdownInSingleSelect(employeeSelect, initialEmployee);
                
                // IMPORTANT: Call updateDynamicRowDateConstraints for the new row's date input
                dateInput.setAttribute('min', startDateInput.value);
                dateInput.setAttribute('max', endDateInput.value);

                // Add onchange listener for immediate feedback
                dateInput.addEventListener('change', () => {
                    const selectedEmployee = employeeSelect.value;
                    const selectedDate = dateInput.value;
                    if (selectedEmployee && selectedDate && employeeLeaveData[selectedEmployee] && employeeLeaveData[selectedEmployee][selectedDate]) {
                        showMessage(`Warning: ${selectedEmployee} is already on leave on ${selectedDate}. Extra pay cannot be applied.`, 'warning');
                        dateInput.value = ''; // Clear the date input to prevent accidental application
                    } else {
                        hideMessage(); // Clear message if valid date is selected
                    }
                });

                removeBtn.addEventListener('click', () => {
                    const employeeName = employeeSelect.value;
                    const dateToRemove = dateInput.value;

                    // Remove from global data if it exists
                    if (employeeName && dateToRemove && employeeExtraPayData[employeeName] && employeeExtraPayData[employeeName][dateToRemove]) {
                        delete employeeExtraPayData[employeeName][dateToRemove];
                        // If no more extra pay for this employee, remove employee entry from data
                        if (Object.keys(employeeExtraPayData[employeeName]).length === 0) {
                            delete employeeExtraPayData[employeeName];
                        }
                        showMessage(`Removed extra pay for ${employeeName} on ${dateToRemove}.`, 'info');
                        generateRoster(); // Regenerate roster to reflect removal
                    } else {
                        showMessage('No specific extra pay record found to remove for this row, just removing the input row.', 'info');
                    }
                    row.remove(); // Remove the HTML row
                    displayExtraPayDetails(); // Update extra pay display
                });

                extraPayInputsContainer.appendChild(row);
                return row;
            }

            /**
             * Applies all extra pay entries from dynamic rows.
             */
            function applyAllExtraPayEntries() {
                let anyApplied = false;
                let errorMessages = []; // Collect specific error messages

                // Create a temporary object to hold all new valid extra pay data
                const tempEmployeeExtraPayData = {};

                const extraPayRows = extraPayInputsContainer.querySelectorAll('.dynamic-input-row');
                if (extraPayRows.length === 0) {
                    showMessage('No extra pay entries to apply.', 'warning');
                    return;
                }

                for (const row of extraPayRows) {
                    const employeeSelect = row.querySelector('.employee-select');
                    const extraPayTypeSelect = row.querySelector('.extra-pay-type-select');
                    const extraPayDateInput = row.querySelector('.extra-pay-date-input');

                    const selectedEmployee = employeeSelect.value;
                    const selectedExtraPayType = extraPayTypeSelect.value;
                    const selectedDateStr = extraPayDateInput.value; // Get the string directly

                    console.log(`DEBUG: Processing Extra Pay Entry - Employee: ${selectedEmployee}, Type: ${selectedExtraPayType}, Date: ${selectedDateStr}`);

                    if (!selectedEmployee || selectedEmployee === "" || !selectedExtraPayType || selectedExtraPayType === "" || !selectedDateStr) {
                        errorMessages.push(`Missing information for an extra pay entry (Employee: "${selectedEmployee}", Date: "${selectedDateStr}").`);
                        console.log(`DEBUG: Skipped due to missing info.`);
                        continue;
                    }

                    const rosterStartDate = parseDateString(startDateInput.value);
                    const rosterEndDate = parseDateString(endDateInput.value);
                    const extraPayDate = parseDateString(selectedDateStr); // Parse the string to a Date object

                    if (extraPayDate < rosterStartDate || extraPayDate > rosterEndDate) {
                        errorMessages.push(`Extra pay date ${selectedDateStr} for ${selectedEmployee} is outside the roster period.`);
                        console.log(`DEBUG: Skipped due to date out of range.`);
                        continue;
                    }

                    // VALIDATION: Check if employee is on leave on this date
                    if (employeeLeaveData[selectedEmployee] && employeeLeaveData[selectedEmployee][selectedDateStr]) {
                        errorMessages.push(`Conflict: ${selectedEmployee} is on leave (${employeeLeaveData[selectedEmployee][selectedDateStr]}) on ${selectedDateStr}. Extra pay cannot be applied.`);
                        console.log(`DEBUG: Skipped due to leave conflict.`);
                        continue;
                    }

                    if (!tempEmployeeExtraPayData[selectedEmployee]) {
                        tempEmployeeExtraPayData[selectedEmployee] = {};
                    }
                    tempEmployeeExtraPayData[selectedEmployee][selectedDateStr] = selectedExtraPayType; // Store the original string
                    anyApplied = true;
                    console.log(`DEBUG: Successfully added extra pay for ${selectedEmployee} on ${selectedDateStr}.`);
                }

                // Replace the global data with the collected valid data
                employeeExtraPayData = tempEmployeeExtraPayData;
                console.log('DEBUG: employeeExtraPayData after applying all:', JSON.stringify(employeeExtraPayData));

                if (anyApplied) {
                    showMessage('All valid extra pay entries applied. Roster updated.', 'success');
                } else if (errorMessages.length > 0) {
                    // If no entries were applied but there were errors
                    showMessage(`Some extra pay entries could not be applied: ${errorMessages.join('; ')}`, 'error');
                } else {
                    showMessage('No new valid extra pay entries were found to apply.', 'info');
                }

                // Always regenerate roster to reflect any changes (additions or removals)
                generateRoster(); 
            }

            /**
             * Displays the details of extra pay entries.
             */
            function displayExtraPayDetails() {
                extraPayList.innerHTML = ''; // Clear previous details
                let hasExtraPayData = false;

                for (const employee in employeeExtraPayData) {
                    const employeeDates = employeeExtraPayData[employee];
                    const extraPayItems = [];

                    for (const date in employeeDates) {
                        const type = employeeDates[date];
                        const formattedType = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ').replace('&', '&');
                        extraPayItems.push(`${date}: ${formattedType}`);
                        hasExtraPayData = true;
                    }

                    if (extraPayItems.length > 0) {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `<strong>${employee}:</strong><br> ${extraPayItems.sort().join('<br>')}`; // Sort by date
                        extraPayList.appendChild(listItem);
                    }
                }

                if (hasExtraPayData) {
                    extraPayOutput.classList.remove('hidden');
                } else {
                    extraPayOutput.classList.add('hidden');
                }
            }


            // Event Listeners
            generateRosterBtn.addEventListener('click', generateRoster);
            exportCsvBtn.addEventListener('click', exportRosterToCSV);
            generateShiftInsightsBtn.addEventListener('click', generateShiftInsights); // Attach LLM function
            clearRosterBtn.addEventListener('click', clearRoster);

            // Event Listeners for Leave Management
            // Listen to all three textareas for input to populate dropdowns
            employeesATextarea.addEventListener('input', populateEmployeeDropdowns); 
            employeesBTextarea.addEventListener('input', populateEmployeeDropdowns);
            employeesCTextarea.addEventListener('input', populateEmployeeDropdowns);

            addLeaveEntryBtn.addEventListener('click', () => createLeaveInputRow()); // Add a new blank row
            applyAllLeaveBtn.addEventListener('click', applyAllLeaveEntries); // Apply all entries

            // Event Listeners for Extra Pay Management
            addExtraPayEntryBtn.addEventListener('click', () => createExtraPayInputRow()); // Add a new blank row
            applyAllExtraPayBtn.addEventListener('click', applyAllExtraPayEntries); // Apply all entries
        });
    </script>
</body>
</html>
